# GitLab CI/CD Template: Cloudflare Worker Deployment
# ======================================================
# Deploy serverless applications to Cloudflare Workers.
#
# Usage:
#   include:
#     - project: 'your-group/mai-gitlab-skill'
#       ref: main
#       file: '/Templates/cloudflare-worker.yml'
#
# Required Variables (set in GitLab CI/CD Settings):
#   CLOUDFLARE_API_TOKEN   - Cloudflare API token with Workers permissions
#   CLOUDFLARE_ACCOUNT_ID  - Your Cloudflare account ID
#
# Optional Variables:
#   WORKER_NAME            - Worker name (default: CI_PROJECT_NAME)
#   WORKER_ENV             - Environment name from wrangler.toml
#   WRANGLER_VERSION       - Wrangler CLI version (default: latest)

stages:
  - install
  - test
  - build
  - deploy

variables:
  WORKER_NAME: ${CI_PROJECT_NAME}
  WRANGLER_VERSION: "latest"

default:
  image: node:20-alpine
  retry:
    max: 1
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

# ------------------------------------------------------------------------------
# Cache Configuration
# ------------------------------------------------------------------------------
cache:
  key:
    files:
      - package-lock.json
      - bun.lockb
      - wrangler.toml
    prefix: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .bun/
  policy: pull-push

# ------------------------------------------------------------------------------
# Install Stage
# ------------------------------------------------------------------------------
install:
  stage: install
  before_script:
    # Install Bun if bun.lockb exists
    - |
      if [ -f "bun.lockb" ]; then
        curl -fsSL https://bun.sh/install | bash
        export PATH="$HOME/.bun/bin:$PATH"
      fi
  script:
    - echo "Installing dependencies..."
    - |
      if [ -f "bun.lockb" ]; then
        bun install --frozen-lockfile
      else
        npm ci
      fi
    # Install wrangler globally
    - npm install -g wrangler@${WRANGLER_VERSION}
    - wrangler --version
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour
  rules:
    - when: always

# ------------------------------------------------------------------------------
# Test Stage
# ------------------------------------------------------------------------------
# Run unit tests
test:
  stage: test
  needs:
    - install
  before_script:
    - |
      if [ -f "bun.lockb" ]; then
        curl -fsSL https://bun.sh/install | bash
        export PATH="$HOME/.bun/bin:$PATH"
      fi
  script:
    - echo "Running tests..."
    - |
      if [ -f "bun.lockb" ]; then
        bun test
      elif [ -f "vitest.config.ts" ] || [ -f "vitest.config.js" ]; then
        npx vitest run
      else
        npm test
      fi
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Type check (for TypeScript workers)
typecheck:
  stage: test
  needs:
    - install
  script:
    - echo "Running type check..."
    - |
      if [ -f "tsconfig.json" ]; then
        npx tsc --noEmit
      else
        echo "No TypeScript configuration found, skipping"
      fi
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ------------------------------------------------------------------------------
# Build Stage
# ------------------------------------------------------------------------------
build:
  stage: build
  needs:
    - install
    - job: test
      optional: true
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
    - |
      if [ -f "bun.lockb" ]; then
        curl -fsSL https://bun.sh/install | bash
        export PATH="$HOME/.bun/bin:$PATH"
      fi
  script:
    - echo "Building worker..."
    # Run build script if it exists
    - |
      if [ -f "bun.lockb" ]; then
        bun run build || true
      else
        npm run build || true
      fi
    # Verify wrangler can parse the configuration
    - wrangler deploy --dry-run --outdir=dist
    - ls -la dist/ || true
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# ------------------------------------------------------------------------------
# Deploy Stage
# ------------------------------------------------------------------------------
# Deploy preview for merge requests
deploy-preview:
  stage: deploy
  needs:
    - build
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
  script:
    - echo "Deploying preview worker..."
    # Deploy to a preview environment
    - |
      wrangler deploy \
        --env preview \
        --var GIT_COMMIT:${CI_COMMIT_SHA} \
        --var GIT_BRANCH:${CI_COMMIT_REF_NAME}
  environment:
    name: preview/$CI_COMMIT_REF_SLUG
    url: https://preview-${WORKER_NAME}.${CLOUDFLARE_ACCOUNT_ID}.workers.dev
    on_stop: stop-preview
    auto_stop_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Stop preview worker when MR is closed
stop-preview:
  stage: deploy
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
  script:
    - echo "Stopping preview worker..."
    - wrangler delete --env preview --force || true
  environment:
    name: preview/$CI_COMMIT_REF_SLUG
    action: stop
  when: manual
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual

# Deploy to staging environment
deploy-staging:
  stage: deploy
  needs:
    - build
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
  script:
    - echo "Deploying to staging..."
    - |
      wrangler deploy \
        --env staging \
        --var GIT_COMMIT:${CI_COMMIT_SHA}
  environment:
    name: staging
    url: https://staging-${WORKER_NAME}.${CLOUDFLARE_ACCOUNT_ID}.workers.dev
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "staging"

# Deploy to production (manual gate)
deploy-production:
  stage: deploy
  needs:
    - build
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
  script:
    - echo "Deploying to production..."
    - |
      wrangler deploy \
        --var GIT_COMMIT:${CI_COMMIT_SHA} \
        --var GIT_TAG:${CI_COMMIT_TAG:-none}
  environment:
    name: production
    url: https://${WORKER_NAME}.${CLOUDFLARE_ACCOUNT_ID}.workers.dev
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
    - if: $CI_COMMIT_TAG
      when: manual

# Auto-deploy releases
deploy-release:
  stage: deploy
  needs:
    - build
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
  script:
    - echo "Deploying release ${CI_COMMIT_TAG}..."
    - |
      wrangler deploy \
        --var GIT_COMMIT:${CI_COMMIT_SHA} \
        --var GIT_TAG:${CI_COMMIT_TAG} \
        --var RELEASE_VERSION:${CI_COMMIT_TAG#v}
  environment:
    name: production
    url: https://${WORKER_NAME}.${CLOUDFLARE_ACCOUNT_ID}.workers.dev
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/

# ------------------------------------------------------------------------------
# Utility Templates
# ------------------------------------------------------------------------------

# Template for workers with KV namespaces
.with_kv:
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
    # Create KV namespace if it doesn't exist
    - |
      wrangler kv:namespace list | grep -q "${KV_NAMESPACE}" || \
        wrangler kv:namespace create "${KV_NAMESPACE}"

# Template for workers with D1 databases
.with_d1:
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
    # Run migrations
    - wrangler d1 migrations apply ${D1_DATABASE} --remote

# Template for workers with R2 buckets
.with_r2:
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
    # Verify R2 bucket exists
    - wrangler r2 bucket list | grep -q "${R2_BUCKET}" || echo "Warning: R2 bucket not found"

# Template for workers with Durable Objects
.with_durable_objects:
  script:
    - |
      wrangler deploy \
        --var GIT_COMMIT:${CI_COMMIT_SHA}
    # Durable Object migrations are handled automatically

# Template for workers with secrets
.with_secrets:
  before_script:
    - npm install -g wrangler@${WRANGLER_VERSION}
    # Set secrets from GitLab CI variables
    - |
      for secret in ${WORKER_SECRETS}; do
        eval "value=\$$secret"
        echo "$value" | wrangler secret put "$secret"
      done

# Template for tail/debugging
.tail_logs:
  stage: .post
  script:
    - wrangler tail --env ${WORKER_ENV:-production} --format pretty
  when: manual
  timeout: 30m
