# GitLab CI/CD Template: Docker Build and Push
# ==============================================
# Docker build with multi-stage support and push to GitLab Container Registry.
#
# Usage:
#   include:
#     - project: 'your-group/mai-gitlab-skill'
#       ref: main
#       file: '/Templates/docker.yml'
#
# Variables:
#   DOCKER_BUILD_CONTEXT  - Build context path (default: .)
#   DOCKERFILE_PATH       - Dockerfile location (default: Dockerfile)
#   DOCKER_BUILD_ARGS     - Additional build arguments
#   IMAGE_TAG             - Override image tag (default: CI_COMMIT_SHA)
#
# The pipeline builds, tests, scans, and pushes images to GitLab Container Registry.

stages:
  - build
  - test
  - scan
  - push

variables:
  # Docker configuration
  DOCKER_BUILD_CONTEXT: "."
  DOCKERFILE_PATH: "Dockerfile"
  DOCKER_BUILD_ARGS: ""
  # Use Docker BuildKit for better caching and performance
  DOCKER_BUILDKIT: "1"
  # Image naming
  IMAGE_TAG: ${CI_COMMIT_SHA}
  # GitLab Container Registry path
  REGISTRY_IMAGE: ${CI_REGISTRY_IMAGE}
  # Cache settings
  DOCKER_DRIVER: overlay2
  # TLS configuration for Docker-in-Docker
  DOCKER_TLS_CERTDIR: "/certs"

# ------------------------------------------------------------------------------
# Docker-in-Docker Service
# ------------------------------------------------------------------------------
# Required for building Docker images within GitLab CI
.docker_dind:
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - docker info
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}

# ------------------------------------------------------------------------------
# Build Stage
# ------------------------------------------------------------------------------
# Builds the Docker image with layer caching for faster subsequent builds.
build:
  extends: .docker_dind
  stage: build
  script:
    - echo "Building Docker image..."
    - |
      # Build with cache from previous builds
      docker build \
        --cache-from ${REGISTRY_IMAGE}:latest \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        ${DOCKER_BUILD_ARGS} \
        -f ${DOCKERFILE_PATH} \
        -t ${REGISTRY_IMAGE}:${IMAGE_TAG} \
        -t ${REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG} \
        ${DOCKER_BUILD_CONTEXT}
    - echo "Build completed successfully"
    # Save image for subsequent stages
    - docker save ${REGISTRY_IMAGE}:${IMAGE_TAG} > image.tar
  artifacts:
    paths:
      - image.tar
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Multi-platform build (ARM64 + AMD64)
build-multiplatform:
  extends: .docker_dind
  stage: build
  script:
    - echo "Setting up Docker Buildx..."
    - docker buildx create --use --name multiplatform-builder
    - docker buildx inspect --bootstrap
    - echo "Building multi-platform image..."
    - |
      docker buildx build \
        --platform linux/amd64,linux/arm64 \
        --cache-from type=registry,ref=${REGISTRY_IMAGE}:cache \
        --cache-to type=registry,ref=${REGISTRY_IMAGE}:cache,mode=max \
        ${DOCKER_BUILD_ARGS} \
        -f ${DOCKERFILE_PATH} \
        -t ${REGISTRY_IMAGE}:${IMAGE_TAG} \
        -t ${REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG} \
        --push \
        ${DOCKER_BUILD_CONTEXT}
  rules:
    - if: $BUILD_MULTIPLATFORM == "true"
    - when: never

# ------------------------------------------------------------------------------
# Test Stage
# ------------------------------------------------------------------------------
# Run container structure tests
test-structure:
  extends: .docker_dind
  stage: test
  needs:
    - build
  script:
    - docker load < image.tar
    - echo "Running container structure tests..."
    # Install container-structure-test
    - |
      wget -q https://storage.googleapis.com/container-structure-test/latest/container-structure-test-linux-amd64 \
        -O /usr/local/bin/container-structure-test
      chmod +x /usr/local/bin/container-structure-test
    # Run tests if config exists
    - |
      if [ -f "container-structure-test.yaml" ]; then
        container-structure-test test \
          --image ${REGISTRY_IMAGE}:${IMAGE_TAG} \
          --config container-structure-test.yaml
      else
        echo "No container-structure-test.yaml found, skipping structure tests"
      fi
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Run smoke tests against the container
test-smoke:
  extends: .docker_dind
  stage: test
  needs:
    - build
  script:
    - docker load < image.tar
    - echo "Running smoke tests..."
    # Start container in background
    - docker run -d --name smoke-test -p 8080:8080 ${REGISTRY_IMAGE}:${IMAGE_TAG}
    - sleep 5
    # Basic health check
    - |
      if docker exec smoke-test curl -sf http://localhost:8080/health; then
        echo "Health check passed"
      else
        echo "Health check failed or /health endpoint not available"
      fi
    - docker logs smoke-test
    - docker stop smoke-test
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ------------------------------------------------------------------------------
# Scan Stage
# ------------------------------------------------------------------------------
# Vulnerability scanning with Trivy
scan-vulnerabilities:
  stage: scan
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  needs:
    - build
  before_script:
    - apk add --no-cache docker-cli
  script:
    - echo "Scanning image for vulnerabilities..."
    # Load the image
    - docker load < image.tar || true
    # Scan from tar directly (works without Docker daemon)
    - |
      trivy image \
        --input image.tar \
        --exit-code 0 \
        --severity HIGH,CRITICAL \
        --format json \
        --output gl-container-scanning-report.json
    # Also output human-readable format
    - trivy image --input image.tar --severity HIGH,CRITICAL
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
    paths:
      - gl-container-scanning-report.json
    expire_in: 1 week
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# ------------------------------------------------------------------------------
# Push Stage
# ------------------------------------------------------------------------------
# Push to GitLab Container Registry
push:
  extends: .docker_dind
  stage: push
  needs:
    - build
    - job: scan-vulnerabilities
      optional: true
  script:
    - docker load < image.tar
    - echo "Pushing image to GitLab Container Registry..."
    - docker push ${REGISTRY_IMAGE}:${IMAGE_TAG}
    - docker push ${REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}
    # Tag as latest on default branch
    - |
      if [ "${CI_COMMIT_BRANCH}" == "${CI_DEFAULT_BRANCH}" ]; then
        docker tag ${REGISTRY_IMAGE}:${IMAGE_TAG} ${REGISTRY_IMAGE}:latest
        docker push ${REGISTRY_IMAGE}:latest
      fi
    - echo "Image pushed successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Push semantic version tags (v1.0.0 -> 1.0.0, 1.0, 1)
push-semver:
  extends: .docker_dind
  stage: push
  needs:
    - build
    - job: scan-vulnerabilities
      optional: true
  script:
    - docker load < image.tar
    - echo "Pushing semantic version tags..."
    # Extract version components
    - |
      VERSION=${CI_COMMIT_TAG#v}
      MAJOR=$(echo $VERSION | cut -d. -f1)
      MINOR=$(echo $VERSION | cut -d. -f2)

      docker tag ${REGISTRY_IMAGE}:${IMAGE_TAG} ${REGISTRY_IMAGE}:${VERSION}
      docker tag ${REGISTRY_IMAGE}:${IMAGE_TAG} ${REGISTRY_IMAGE}:${MAJOR}.${MINOR}
      docker tag ${REGISTRY_IMAGE}:${IMAGE_TAG} ${REGISTRY_IMAGE}:${MAJOR}

      docker push ${REGISTRY_IMAGE}:${VERSION}
      docker push ${REGISTRY_IMAGE}:${MAJOR}.${MINOR}
      docker push ${REGISTRY_IMAGE}:${MAJOR}
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/

# ------------------------------------------------------------------------------
# Utility Templates
# ------------------------------------------------------------------------------

# Template for pushing to external registry (DockerHub, ECR, etc.)
.push_external:
  extends: .docker_dind
  stage: push
  needs:
    - build
  script:
    - docker load < image.tar
    # Login to external registry (set EXTERNAL_REGISTRY_* variables)
    - docker login -u ${EXTERNAL_REGISTRY_USER} -p ${EXTERNAL_REGISTRY_PASSWORD} ${EXTERNAL_REGISTRY_HOST}
    - docker tag ${REGISTRY_IMAGE}:${IMAGE_TAG} ${EXTERNAL_REGISTRY_IMAGE}:${IMAGE_TAG}
    - docker push ${EXTERNAL_REGISTRY_IMAGE}:${IMAGE_TAG}
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual

# Template for cleanup
.cleanup:
  extends: .docker_dind
  stage: .post
  script:
    - docker system prune -f
  when: always
