#!/bin/bash

#
# Internal Pentest - Initial Discovery Script
# Passive situational awareness: IP, subnet, gateway, DNS, domain, DCs
#
# Usage: ./initial-discovery.sh
#
# No arguments required. Run this FIRST when you land on a box
# (physical port, VPN, WiFi) before running network-discovery.sh.
#
# This script performs LOCAL and LOW-NOISE operations:
#   - Reads local interface configuration
#   - Multi-method domain/DNS enumeration:
#     DNS (SRV, SOA, ANY, CHAOS, PTR sweep)
#     LDAP (RootDSE, LDAPS, SASL, schema attributes)
#     SMB (null session domain disclosure)
#     RPC (srvinfo, enumdomains, lsaquery)
#     NetBIOS (nbtscan, nmblookup)
#     Kerberos (realm probe via kinit)
#     Port signatures (nmap DC ports)
#   - Reads ARP cache (or arp-scan if available)
#   - Pings gateway and DC candidates
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Configuration
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
OUTPUT_DIR="../outputs/initial-discovery"
TARGETS_DIR="../targets"
LOGFILE="${OUTPUT_DIR}/initial-discovery_${TIMESTAMP}.txt"

echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║  Internal Pentest - Initial Discovery (Phase 0)            ║${NC}"
echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}"
echo -e "${BLUE}[*] Timestamp: ${TIMESTAMP}${NC}"
echo ""

# Create output directories
mkdir -p "$OUTPUT_DIR" "$TARGETS_DIR"

# Start log
echo "=== Initial Discovery - ${TIMESTAMP} ===" > "$LOGFILE"
echo "" >> "$LOGFILE"

# Detect platform
PLATFORM="unknown"
if [[ "$(uname)" == "Darwin" ]]; then
    PLATFORM="macos"
elif [[ "$(uname)" == "Linux" ]]; then
    PLATFORM="linux"
fi
echo -e "${BLUE}[*] Platform: ${PLATFORM}${NC}"
echo "Platform: ${PLATFORM}" >> "$LOGFILE"
echo "" >> "$LOGFILE"

# Helper: log and display
log() {
    echo -e "$1"
    echo -e "$1" | sed 's/\x1b\[[0-9;]*m//g' >> "$LOGFILE"
}

# ============================================================
# STEP 1: Network Interface & IP Address
# ============================================================
echo -e "\n${CYAN}━━━ Step 1: Network Interface & IP Address ━━━${NC}"
echo "" >> "$LOGFILE"
echo "=== Step 1: Network Interface & IP Address ===" >> "$LOGFILE"

IFACE=""
LOCAL_IP=""
NETMASK=""
CIDR_BITS=""
NETWORK_CIDR=""

if [[ "$PLATFORM" == "linux" ]]; then
    # Get the default route interface
    IFACE=$(ip route show default 2>/dev/null | awk '{print $5; exit}')

    if [[ -n "$IFACE" ]]; then
        LOCAL_IP=$(ip -4 addr show "$IFACE" 2>/dev/null | grep -oP 'inet \K[0-9.]+' | head -1)
        CIDR_BITS=$(ip -4 addr show "$IFACE" 2>/dev/null | grep -oP 'inet [0-9.]+/\K[0-9]+' | head -1)
    fi
elif [[ "$PLATFORM" == "macos" ]]; then
    # Get the default route interface
    IFACE=$(netstat -rn 2>/dev/null | grep '^default' | head -1 | awk '{print $NF}')

    if [[ -n "$IFACE" ]]; then
        LOCAL_IP=$(ifconfig "$IFACE" 2>/dev/null | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}' | head -1)
        NETMASK_HEX=$(ifconfig "$IFACE" 2>/dev/null | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $4}' | head -1)

        # Convert hex netmask (0xffffff00) to CIDR bits
        if [[ -n "$NETMASK_HEX" && "$NETMASK_HEX" == 0x* ]]; then
            # Convert hex to binary and count 1s
            CIDR_BITS=$(python3 -c "print(bin(int('${NETMASK_HEX}', 16)).count('1'))" 2>/dev/null || echo "")
        fi
    fi
fi

if [[ -n "$LOCAL_IP" ]]; then
    log "${GREEN}[+] Active Interface: ${IFACE}${NC}"
    log "${GREEN}[+] Local IP Address: ${LOCAL_IP}${NC}"
    log "${GREEN}[+] CIDR Prefix:      /${CIDR_BITS}${NC}"
else
    log "${RED}[!] Could not determine local IP address${NC}"
    log "${YELLOW}[*] Try manually: ip addr (Linux) or ifconfig (macOS)${NC}"
fi

# ============================================================
# STEP 2: Calculate Subnet / CIDR Range
# ============================================================
echo -e "\n${CYAN}━━━ Step 2: Subnet / CIDR Range ━━━${NC}"
echo "" >> "$LOGFILE"
echo "=== Step 2: Subnet / CIDR Range ===" >> "$LOGFILE"

if [[ -n "$LOCAL_IP" && -n "$CIDR_BITS" ]]; then
    # Calculate network address using Python for portability
    NETWORK_CIDR=$(python3 -c "
import ipaddress
iface = ipaddress.ip_interface('${LOCAL_IP}/${CIDR_BITS}')
print(str(iface.network))
" 2>/dev/null || echo "")

    if [[ -n "$NETWORK_CIDR" ]]; then
        log "${GREEN}[+] Subnet CIDR: ${NETWORK_CIDR}${NC}"

        # Write to targets/ranges.txt
        echo "$NETWORK_CIDR" > "$TARGETS_DIR/ranges.txt"
        log "${GREEN}[+] Written to ${TARGETS_DIR}/ranges.txt${NC}"
    else
        log "${YELLOW}[!] Could not calculate network CIDR${NC}"
    fi
else
    log "${YELLOW}[!] Insufficient data to calculate CIDR (IP: ${LOCAL_IP}, prefix: ${CIDR_BITS})${NC}"
fi

# ============================================================
# STEP 3: Default Gateway
# ============================================================
echo -e "\n${CYAN}━━━ Step 3: Default Gateway ━━━${NC}"
echo "" >> "$LOGFILE"
echo "=== Step 3: Default Gateway ===" >> "$LOGFILE"

GATEWAY=""

if [[ "$PLATFORM" == "linux" ]]; then
    GATEWAY=$(ip route show default 2>/dev/null | awk '{print $3; exit}')
elif [[ "$PLATFORM" == "macos" ]]; then
    GATEWAY=$(netstat -rn 2>/dev/null | grep '^default' | head -1 | awk '{print $2}')
fi

if [[ -n "$GATEWAY" ]]; then
    log "${GREEN}[+] Default Gateway: ${GATEWAY}${NC}"
else
    log "${YELLOW}[!] Could not determine default gateway${NC}"
fi

# ============================================================
# STEP 4: DNS Servers
# ============================================================
echo -e "\n${CYAN}━━━ Step 4: DNS Servers ━━━${NC}"
echo "" >> "$LOGFILE"
echo "=== Step 4: DNS Servers ===" >> "$LOGFILE"

DNS_SERVERS=""

# /etc/resolv.conf (both platforms)
if [[ -f /etc/resolv.conf ]]; then
    DNS_SERVERS=$(grep '^nameserver' /etc/resolv.conf 2>/dev/null | awk '{print $2}' | tr '\n' ' ')
fi

# Also check DHCP lease files on Linux for additional DNS info
if [[ "$PLATFORM" == "linux" ]]; then
    shopt -s nullglob
    for lease_file in /var/lib/dhcp/dhclient*.leases /var/lib/NetworkManager/*.lease; do
        if [[ -f "$lease_file" ]]; then
            LEASE_DNS=$(grep 'domain-name-servers' "$lease_file" 2>/dev/null | tail -1 | grep -oP '[\d.]+' | tr '\n' ' ')
            if [[ -n "$LEASE_DNS" ]]; then
                DNS_SERVERS="${DNS_SERVERS} ${LEASE_DNS}"
            fi
        fi
    done
    shopt -u nullglob
fi

# macOS: also check scutil
if [[ "$PLATFORM" == "macos" ]]; then
    SCUTIL_DNS=$(scutil --dns 2>/dev/null | grep 'nameserver\[' | awk '{print $3}' | sort -u | tr '\n' ' ')
    if [[ -n "$SCUTIL_DNS" ]]; then
        DNS_SERVERS="${DNS_SERVERS} ${SCUTIL_DNS}"
    fi
fi

# Deduplicate
DNS_SERVERS=$(echo "$DNS_SERVERS" | tr ' ' '\n' | sort -u | tr '\n' ' ' | xargs)

if [[ -n "$DNS_SERVERS" ]]; then
    log "${GREEN}[+] DNS Servers: ${DNS_SERVERS}${NC}"
else
    log "${YELLOW}[!] Could not determine DNS servers${NC}"
fi

# ============================================================
# STEP 5: Domain & DNS Enumeration (Multi-Method)
# ============================================================
echo -e "\n${CYAN}━━━ Step 5: Domain & DNS Enumeration ━━━${NC}"
echo "" >> "$LOGFILE"
echo "=== Step 5: Domain & DNS Enumeration (Multi-Method) ===" >> "$LOGFILE"

DOMAIN=""
NETBIOS_DOMAIN=""
DC_IPS=""
DC_HOSTNAMES=""
ENUM_DETAIL_LOG="${OUTPUT_DIR}/domain-enum-detail_${TIMESTAMP}.txt"
echo "=== Domain Enumeration Detail Log - ${TIMESTAMP} ===" > "$ENUM_DETAIL_LOG"

# Build list of candidate DC IPs (DNS servers are DCs in most AD environments)
CANDIDATE_IPS=""
for dns_ip in $DNS_SERVERS; do
    CANDIDATE_IPS="${CANDIDATE_IPS} ${dns_ip}"
done
# Gateway can also be a candidate in smaller networks
if [[ -n "$GATEWAY" ]]; then
    CANDIDATE_IPS="${CANDIDATE_IPS} ${GATEWAY}"
fi
CANDIDATE_IPS=$(echo "$CANDIDATE_IPS" | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')

log "${BLUE}[*] Candidate DC IPs (from DNS/gateway): ${CANDIDATE_IPS}${NC}"

# Helper: check if a tool exists
has_tool() {
    command -v "$1" &>/dev/null
}

# Helper: record a domain finding
record_domain() {
    local found_domain="$1"
    local source="$2"
    if [[ -n "$found_domain" && -z "$DOMAIN" ]]; then
        DOMAIN="$found_domain"
        log "${GREEN}[+] AD Domain discovered: ${DOMAIN} (via ${source})${NC}"
    elif [[ -n "$found_domain" && "$found_domain" != "$DOMAIN" ]]; then
        log "${BLUE}[*] Additional domain reference: ${found_domain} (via ${source})${NC}"
    fi
}

# Helper: record a NetBIOS domain finding
record_netbios() {
    local found_nb="$1"
    local source="$2"
    if [[ -n "$found_nb" && -z "$NETBIOS_DOMAIN" ]]; then
        NETBIOS_DOMAIN="$found_nb"
        log "${GREEN}[+] NetBIOS Domain: ${NETBIOS_DOMAIN} (via ${source})${NC}"
    fi
}

# Helper: record a DC IP
record_dc_ip() {
    local ip="$1"
    local source="$2"
    if [[ -n "$ip" && "$ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        if ! echo -e "$DC_IPS" | grep -q "^${ip}$"; then
            DC_IPS="${DC_IPS}${ip}\n"
            log "${GREEN}[+] DC IP: ${ip} (via ${source})${NC}"
        fi
    fi
}

# Helper: record a DC hostname
record_dc_hostname() {
    local hostname="$1"
    if [[ -n "$hostname" ]]; then
        DC_HOSTNAMES="${DC_HOSTNAMES}${hostname}\n"
    fi
}

# ---- 5a: resolv.conf search/domain ----
log "${BLUE}[*] 5a: Checking resolv.conf for search domain...${NC}"
SEARCH_DOMAIN=""
if [[ -f /etc/resolv.conf ]]; then
    SEARCH_DOMAIN=$(grep -E '^(search|domain)' /etc/resolv.conf 2>/dev/null | awk '{print $2}' | head -1)
    if [[ -n "$SEARCH_DOMAIN" ]]; then
        log "${GREEN}[+] DNS search domain: ${SEARCH_DOMAIN}${NC}"
        cat /etc/resolv.conf >> "$ENUM_DETAIL_LOG" 2>/dev/null
    fi
fi

# ---- 5b: DNS AD SRV probe ----
log "${BLUE}[*] 5b: DNS SRV lookup for AD domain controllers...${NC}"
try_srv_lookup() {
    local domain="$1"
    local target_dns="$2"
    local result=""

    if has_tool dig; then
        if [[ -n "$target_dns" ]]; then
            result=$(dig @"$target_dns" SRV "_ldap._tcp.dc._msdcs.${domain}" +short 2>/dev/null || true)
        else
            result=$(dig SRV "_ldap._tcp.dc._msdcs.${domain}" +short 2>/dev/null || true)
        fi
    elif has_tool nslookup; then
        result=$(nslookup -type=SRV "_ldap._tcp.dc._msdcs.${domain}" ${target_dns} 2>/dev/null || true)
    elif has_tool host; then
        result=$(host -t SRV "_ldap._tcp.dc._msdcs.${domain}" ${target_dns} 2>/dev/null || true)
    fi
    echo "$result"
}

# Try SRV with search domain against each DNS server
SRV_FOUND=false
for try_domain in $SEARCH_DOMAIN; do
    [[ -z "$try_domain" ]] && continue
    for dns_ip in $DNS_SERVERS; do
        SRV_RESULT=$(try_srv_lookup "$try_domain" "$dns_ip")
        echo "--- SRV @${dns_ip} for ${try_domain} ---" >> "$ENUM_DETAIL_LOG"
        echo "$SRV_RESULT" >> "$ENUM_DETAIL_LOG"

        if echo "$SRV_RESULT" | grep -qiE "service|SRV|priority|weight|port|[0-9]+ [0-9]+ [0-9]+ "; then
            record_domain "$try_domain" "DNS SRV _ldap._tcp @${dns_ip}"
            SRV_FOUND=true

            # Extract DC hostnames and resolve
            if has_tool dig; then
                DC_SRV_HOSTS=$(dig @"$dns_ip" SRV "_ldap._tcp.dc._msdcs.${try_domain}" +short 2>/dev/null | awk '{print $4}' | sed 's/\.$//')
            else
                DC_SRV_HOSTS=$(echo "$SRV_RESULT" | grep -oE '[a-zA-Z0-9._-]+\.[a-zA-Z]{2,}' | sort -u)
            fi

            for dc_host in $DC_SRV_HOSTS; do
                record_dc_hostname "$dc_host"
                dc_ip=$(dig +short "$dc_host" 2>/dev/null | head -1)
                [[ -z "$dc_ip" ]] && dc_ip=$(dig @"$dns_ip" +short "$dc_host" 2>/dev/null | head -1)
                record_dc_ip "$dc_ip" "SRV resolve ${dc_host}"
            done
            break 2
        fi
    done
done

# Also try without specifying DNS server (system resolver)
if [[ "$SRV_FOUND" == false && -n "$SEARCH_DOMAIN" ]]; then
    SRV_RESULT=$(try_srv_lookup "$SEARCH_DOMAIN" "")
    if echo "$SRV_RESULT" | grep -qiE "service|SRV|priority|weight|port|[0-9]+ [0-9]+ [0-9]+ "; then
        record_domain "$SEARCH_DOMAIN" "DNS SRV _ldap._tcp (system resolver)"
        SRV_FOUND=true
    fi
fi

# ---- 5c: DNS SOA probe ----
log "${BLUE}[*] 5c: DNS SOA probe...${NC}"
for dns_ip in $DNS_SERVERS; do
    if has_tool dig; then
        SOA_RESULT=$(dig @"$dns_ip" SOA . +short 2>/dev/null || true)
        echo "--- SOA @${dns_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$SOA_RESULT" >> "$ENUM_DETAIL_LOG"
        if [[ -n "$SOA_RESULT" ]]; then
            # SOA returns primary NS — extract domain from the MNAME
            SOA_NS=$(echo "$SOA_RESULT" | awk '{print $1}' | sed 's/\.$//')
            if [[ -n "$SOA_NS" ]]; then
                SOA_DOMAIN=$(echo "$SOA_NS" | awk -F. '{for(i=2;i<=NF;i++) printf "%s%s", $i, (i<NF?".":"")}')
                log "${BLUE}[*] SOA primary NS: ${SOA_NS}${NC}"
                [[ -n "$SOA_DOMAIN" ]] && record_domain "$SOA_DOMAIN" "DNS SOA @${dns_ip}"
            fi
        fi
    fi
done

# ---- 5d: DNS ANY probe ----
log "${BLUE}[*] 5d: DNS ANY probe...${NC}"
for dns_ip in $DNS_SERVERS; do
    if has_tool dig; then
        ANY_RESULT=$(dig @"$dns_ip" ANY . 2>/dev/null || true)
        echo "--- ANY @${dns_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$ANY_RESULT" >> "$ENUM_DETAIL_LOG"
        if [[ -n "$ANY_RESULT" ]]; then
            log "${BLUE}[*] DNS ANY response received from ${dns_ip} (see detail log)${NC}"
        fi
    fi
done

# ---- 5e: DNS CHAOS TXT version probe ----
log "${BLUE}[*] 5e: DNS version banner probe...${NC}"
for dns_ip in $DNS_SERVERS; do
    if has_tool dig; then
        CHAOS_RESULT=$(dig @"$dns_ip" CHAOS TXT version.bind +short 2>/dev/null || true)
        echo "--- CHAOS TXT @${dns_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$CHAOS_RESULT" >> "$ENUM_DETAIL_LOG"
        if [[ -n "$CHAOS_RESULT" ]]; then
            log "${GREEN}[+] DNS version @${dns_ip}: ${CHAOS_RESULT}${NC}"
        fi
    fi
done

# ---- 5f: PTR sweep for FQDN leaks ----
log "${BLUE}[*] 5f: PTR reverse lookup sweep...${NC}"
if [[ -n "$NETWORK_CIDR" ]] && has_tool dig; then
    DNS_TARGET=$(echo "$DNS_SERVERS" | awk '{print $1}')
    if [[ -n "$DNS_TARGET" ]]; then
        # Extract base network and sweep up to 254 hosts (limit to /24 or smaller)
        BASE_NET=$(echo "$LOCAL_IP" | awk -F. '{print $1"."$2"."$3}')
        PTR_COUNT=0
        PTR_RESULTS=""
        for i in $(seq 1 254); do
            PTR=$(dig @"$DNS_TARGET" -x "${BASE_NET}.${i}" +short +time=1 +tries=1 2>/dev/null | head -1 | sed 's/\.$//')
            if [[ -n "$PTR" ]]; then
                PTR_RESULTS="${PTR_RESULTS}${BASE_NET}.${i} -> ${PTR}\n"
                PTR_COUNT=$((PTR_COUNT + 1))

                # Extract domain from FQDN if we don't have one
                if [[ -z "$DOMAIN" ]]; then
                    PTR_DOMAIN=$(echo "$PTR" | awk -F. '{for(i=2;i<=NF;i++) printf "%s%s", $i, (i<NF?".":"")}')
                    [[ -n "$PTR_DOMAIN" && $(echo "$PTR_DOMAIN" | grep -c '\.') -ge 1 ]] && record_domain "$PTR_DOMAIN" "PTR reverse lookup"
                fi
            fi
        done
        echo -e "--- PTR sweep ${BASE_NET}.0/24 ---" >> "$ENUM_DETAIL_LOG"
        echo -e "$PTR_RESULTS" >> "$ENUM_DETAIL_LOG"
        if [[ "$PTR_COUNT" -gt 0 ]]; then
            log "${GREEN}[+] PTR sweep found ${PTR_COUNT} hostnames (see detail log)${NC}"
            # Show first few
            echo -e "$PTR_RESULTS" | head -5 | while IFS= read -r line; do
                [[ -n "$line" ]] && log "    ${line}"
            done
            [[ "$PTR_COUNT" -gt 5 ]] && log "    ... (${PTR_COUNT} total)"
        else
            log "${YELLOW}[!] PTR sweep returned no results${NC}"
        fi
    fi
else
    log "${YELLOW}[!] Skipping PTR sweep (no CIDR or dig not available)${NC}"
fi

# ---- 5g: LDAP RootDSE enumeration ----
log "${BLUE}[*] 5g: LDAP RootDSE enumeration...${NC}"
if has_tool ldapsearch; then
    for candidate_ip in $CANDIDATE_IPS; do
        # Standard LDAP (389)
        LDAP_RESULT=$(ldapsearch -x -H "ldap://${candidate_ip}" -s base "" namingContexts 2>/dev/null || true)
        echo "--- LDAP RootDSE @${candidate_ip}:389 ---" >> "$ENUM_DETAIL_LOG"
        echo "$LDAP_RESULT" >> "$ENUM_DETAIL_LOG"

        if echo "$LDAP_RESULT" | grep -qi "namingContexts"; then
            # Extract domain from defaultNamingContext (DC=corp,DC=local -> corp.local)
            NAMING_CTX=$(echo "$LDAP_RESULT" | grep -i 'namingContexts' | head -1 | awk '{print $2}')
            if [[ -n "$NAMING_CTX" ]]; then
                LDAP_DOMAIN=$(echo "$NAMING_CTX" | sed 's/DC=//gi; s/,/./g')
                log "${GREEN}[+] LDAP RootDSE @${candidate_ip}: ${NAMING_CTX}${NC}"
                record_domain "$LDAP_DOMAIN" "LDAP RootDSE @${candidate_ip}"
                record_dc_ip "$candidate_ip" "LDAP RootDSE responds"
            fi
        fi

        # LDAPS (636)
        LDAPS_RESULT=$(ldapsearch -x -H "ldaps://${candidate_ip}:636" -s base "" namingContexts 2>/dev/null || true)
        echo "--- LDAPS RootDSE @${candidate_ip}:636 ---" >> "$ENUM_DETAIL_LOG"
        echo "$LDAPS_RESULT" >> "$ENUM_DETAIL_LOG"

        if echo "$LDAPS_RESULT" | grep -qi "namingContexts"; then
            NAMING_CTX=$(echo "$LDAPS_RESULT" | grep -i 'namingContexts' | head -1 | awk '{print $2}')
            if [[ -n "$NAMING_CTX" ]]; then
                LDAP_DOMAIN=$(echo "$NAMING_CTX" | sed 's/DC=//gi; s/,/./g')
                log "${GREEN}[+] LDAPS RootDSE @${candidate_ip}:636: ${NAMING_CTX}${NC}"
                record_domain "$LDAP_DOMAIN" "LDAPS @${candidate_ip}"
                record_dc_ip "$candidate_ip" "LDAPS responds"
            fi
        fi

        # SASL mechanisms check
        SASL_RESULT=$(ldapsearch -x -H "ldap://${candidate_ip}" -s base "" supportedSASLMechanisms 2>/dev/null || true)
        echo "--- LDAP SASL @${candidate_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$SASL_RESULT" >> "$ENUM_DETAIL_LOG"

        if echo "$SASL_RESULT" | grep -qi "GSSAPI\|GSS-SPNEGO"; then
            log "${GREEN}[+] LDAP SASL @${candidate_ip}: Kerberos auth supported (AD confirmed)${NC}"
            record_dc_ip "$candidate_ip" "LDAP SASL GSSAPI"
        fi

        # Schema/RootDSE alternate attributes
        SCHEMA_RESULT=$(ldapsearch -x -H "ldap://${candidate_ip}" -s base "" subschemaSubentry dnsHostName serverName 2>/dev/null || true)
        echo "--- LDAP schema @${candidate_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$SCHEMA_RESULT" >> "$ENUM_DETAIL_LOG"

        DNS_HOSTNAME=$(echo "$SCHEMA_RESULT" | grep -i 'dnsHostName' | awk '{print $2}')
        if [[ -n "$DNS_HOSTNAME" ]]; then
            log "${GREEN}[+] LDAP dnsHostName @${candidate_ip}: ${DNS_HOSTNAME}${NC}"
            record_dc_hostname "$DNS_HOSTNAME"
        fi
    done
else
    log "${YELLOW}[!] ldapsearch not found — skipping LDAP enumeration${NC}"
fi

# ---- 5h: SMB domain disclosure ----
log "${BLUE}[*] 5h: SMB domain disclosure...${NC}"
if has_tool smbclient; then
    for candidate_ip in $CANDIDATE_IPS; do
        SMB_RESULT=$(smbclient -L "//${candidate_ip}" -N 2>&1 || true)
        echo "--- SMB @${candidate_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$SMB_RESULT" >> "$ENUM_DETAIL_LOG"

        # Extract domain from the Workgroup line
        SMB_DOMAIN=$(echo "$SMB_RESULT" | grep -i 'domain=' | grep -oP 'domain=\[\K[^\]]+' || true)
        if [[ -z "$SMB_DOMAIN" ]]; then
            SMB_DOMAIN=$(echo "$SMB_RESULT" | grep -i 'workgroup' | awk -F'\\' '{print $1}' | awk '{print $NF}' || true)
        fi
        if [[ -z "$SMB_DOMAIN" ]]; then
            # Try grep for domain hints
            SMB_DOMAIN=$(echo "$SMB_RESULT" | grep -ioP 'domain[=: ]+\K[a-zA-Z0-9._-]+' | head -1 || true)
        fi

        if [[ -n "$SMB_DOMAIN" ]]; then
            log "${GREEN}[+] SMB domain @${candidate_ip}: ${SMB_DOMAIN}${NC}"
            record_netbios "$SMB_DOMAIN" "SMB @${candidate_ip}"
            record_dc_ip "$candidate_ip" "SMB domain disclosure"
        fi
    done
else
    log "${YELLOW}[!] smbclient not found — skipping SMB enumeration${NC}"
fi

# ---- 5i: RPC domain leakage ----
log "${BLUE}[*] 5i: RPC domain enumeration...${NC}"
if has_tool rpcclient; then
    for candidate_ip in $CANDIDATE_IPS; do
        # srvinfo
        RPC_SRVINFO=$(rpcclient -U "" -N "$candidate_ip" -c "srvinfo" 2>/dev/null || true)
        echo "--- RPC srvinfo @${candidate_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$RPC_SRVINFO" >> "$ENUM_DETAIL_LOG"
        if [[ -n "$RPC_SRVINFO" ]] && ! echo "$RPC_SRVINFO" | grep -qi "error\|failed\|denied"; then
            log "${GREEN}[+] RPC srvinfo @${candidate_ip}: responded${NC}"
            echo "$RPC_SRVINFO" | head -3 | while IFS= read -r line; do
                [[ -n "$line" ]] && log "    ${line}"
            done
        fi

        # enumdomains
        RPC_ENUMDOM=$(rpcclient -U "" -N "$candidate_ip" -c "enumdomains" 2>/dev/null || true)
        echo "--- RPC enumdomains @${candidate_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$RPC_ENUMDOM" >> "$ENUM_DETAIL_LOG"
        if [[ -n "$RPC_ENUMDOM" ]] && ! echo "$RPC_ENUMDOM" | grep -qi "error\|failed\|denied"; then
            RPC_DOM_NAME=$(echo "$RPC_ENUMDOM" | grep -oP 'name:\[\K[^\]]+' | head -1 || true)
            if [[ -n "$RPC_DOM_NAME" ]]; then
                log "${GREEN}[+] RPC enumdomains @${candidate_ip}: ${RPC_DOM_NAME}${NC}"
                record_netbios "$RPC_DOM_NAME" "RPC enumdomains @${candidate_ip}"
                record_dc_ip "$candidate_ip" "RPC enumdomains"
            fi
        fi

        # lsaquery
        RPC_LSA=$(rpcclient -U "" -N "$candidate_ip" -c "lsaquery" 2>/dev/null || true)
        echo "--- RPC lsaquery @${candidate_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$RPC_LSA" >> "$ENUM_DETAIL_LOG"
        if [[ -n "$RPC_LSA" ]] && ! echo "$RPC_LSA" | grep -qi "error\|failed\|denied"; then
            LSA_DOMAIN=$(echo "$RPC_LSA" | grep -i 'Domain Name' | awk -F: '{print $2}' | xargs || true)
            LSA_SID=$(echo "$RPC_LSA" | grep -i 'Domain Sid' | awk -F: '{print $2}' | xargs || true)
            if [[ -n "$LSA_DOMAIN" ]]; then
                log "${GREEN}[+] RPC lsaquery @${candidate_ip}: Domain=${LSA_DOMAIN} SID=${LSA_SID}${NC}"
                record_netbios "$LSA_DOMAIN" "RPC lsaquery @${candidate_ip}"
                record_dc_ip "$candidate_ip" "RPC lsaquery"
            fi
        fi
    done
else
    log "${YELLOW}[!] rpcclient not found — skipping RPC enumeration${NC}"
fi

# ---- 5j: NetBIOS enumeration ----
log "${BLUE}[*] 5j: NetBIOS enumeration...${NC}"

# nbtscan subnet sweep
if has_tool nbtscan && [[ -n "$NETWORK_CIDR" ]]; then
    NBTSCAN_RESULT=$(nbtscan "$NETWORK_CIDR" 2>/dev/null || true)
    echo "--- nbtscan ${NETWORK_CIDR} ---" >> "$ENUM_DETAIL_LOG"
    echo "$NBTSCAN_RESULT" >> "$ENUM_DETAIL_LOG"
    if [[ -n "$NBTSCAN_RESULT" ]]; then
        NB_COUNT=$(echo "$NBTSCAN_RESULT" | grep -cP '^\d+\.\d+' || echo "0")
        log "${GREEN}[+] nbtscan found ${NB_COUNT} NetBIOS hosts${NC}"
        # Look for DC markers (<1b> = domain master browser = PDC)
        NB_DC=$(echo "$NBTSCAN_RESULT" | grep '<1b>' | awk '{print $1}' || true)
        if [[ -n "$NB_DC" ]]; then
            for nb_dc_ip in $NB_DC; do
                log "${GREEN}[+] NetBIOS DC (PDC/domain master): ${nb_dc_ip}${NC}"
                record_dc_ip "$nb_dc_ip" "nbtscan <1b> domain master"
            done
        fi
    fi
elif ! has_tool nbtscan; then
    log "${YELLOW}[!] nbtscan not found — skipping subnet NetBIOS sweep${NC}"
fi

# nmblookup per candidate
if has_tool nmblookup; then
    for candidate_ip in $CANDIDATE_IPS; do
        NMB_RESULT=$(nmblookup -A "$candidate_ip" 2>/dev/null || true)
        echo "--- nmblookup -A ${candidate_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$NMB_RESULT" >> "$ENUM_DETAIL_LOG"
        if [[ -n "$NMB_RESULT" ]] && ! echo "$NMB_RESULT" | grep -qi "error\|failed"; then
            NMB_NAME=$(echo "$NMB_RESULT" | grep '<00>' | head -1 | awk '{print $1}' || true)
            NMB_GROUP=$(echo "$NMB_RESULT" | grep '<00>' | grep '<GROUP>' | head -1 | awk '{print $1}' || true)
            if [[ -n "$NMB_NAME" ]]; then
                log "${GREEN}[+] nmblookup @${candidate_ip}: name=${NMB_NAME} group=${NMB_GROUP}${NC}"
                [[ -n "$NMB_GROUP" ]] && record_netbios "$NMB_GROUP" "nmblookup @${candidate_ip}"
            fi
        fi
    done
else
    log "${YELLOW}[!] nmblookup not found — skipping per-host NetBIOS lookup${NC}"
fi

# ---- 5k: Kerberos realm discovery ----
log "${BLUE}[*] 5k: Kerberos realm discovery...${NC}"
if has_tool kinit; then
    # kinit with a fake user will error but may reveal the realm
    KINIT_RESULT=$(echo "" | kinit "fakeuser_probe@DOESNOTEXIST.LOCAL" 2>&1 || true)
    echo "--- kinit probe ---" >> "$ENUM_DETAIL_LOG"
    echo "$KINIT_RESULT" >> "$ENUM_DETAIL_LOG"

    # If we have a candidate domain, try that realm
    if [[ -n "$DOMAIN" ]]; then
        REALM=$(echo "$DOMAIN" | tr '[:lower:]' '[:upper:]')
        KINIT_REAL=$(echo "" | kinit "fakeuser_probe@${REALM}" 2>&1 || true)
        echo "--- kinit @${REALM} ---" >> "$ENUM_DETAIL_LOG"
        echo "$KINIT_REAL" >> "$ENUM_DETAIL_LOG"

        if echo "$KINIT_REAL" | grep -qi "pre-authentication\|principal\|client not found\|unknown"; then
            log "${GREEN}[+] Kerberos realm ${REALM} is valid (KDC responded)${NC}"
        elif echo "$KINIT_REAL" | grep -qi "cannot resolve\|no such"; then
            log "${YELLOW}[!] Kerberos realm ${REALM} not resolvable${NC}"
        fi
    fi

    # Also check /etc/krb5.conf for hints
    if [[ -f /etc/krb5.conf ]]; then
        KRB_REALM=$(grep 'default_realm' /etc/krb5.conf 2>/dev/null | awk -F= '{print $2}' | xargs || true)
        if [[ -n "$KRB_REALM" ]]; then
            log "${GREEN}[+] krb5.conf default_realm: ${KRB_REALM}${NC}"
            KRB_DOMAIN=$(echo "$KRB_REALM" | tr '[:upper:]' '[:lower:]')
            record_domain "$KRB_DOMAIN" "krb5.conf"
        fi
    fi
else
    log "${YELLOW}[!] kinit not found — skipping Kerberos realm discovery${NC}"
fi

# ---- 5l: Reverse DNS of DNS servers for FQDN ----
if [[ -z "$DOMAIN" ]]; then
    log "${BLUE}[*] 5l: Reverse DNS of candidate IPs for domain hints...${NC}"
    for candidate_ip in $CANDIDATE_IPS; do
        if has_tool dig; then
            REVERSE=$(dig -x "$candidate_ip" +short 2>/dev/null | head -1 | sed 's/\.$//')
        elif has_tool nslookup; then
            REVERSE=$(nslookup "$candidate_ip" 2>/dev/null | grep -i 'name' | head -1 | awk '{print $NF}' | sed 's/\.$//')
        else
            REVERSE=""
        fi

        if [[ -n "$REVERSE" ]]; then
            log "${GREEN}[+] Reverse DNS ${candidate_ip}: ${REVERSE}${NC}"
            POSSIBLE_DOMAIN=$(echo "$REVERSE" | awk -F. '{for(i=2;i<=NF;i++) printf "%s%s", $i, (i<NF?".":"")}')
            if [[ -n "$POSSIBLE_DOMAIN" && $(echo "$POSSIBLE_DOMAIN" | grep -c '\.') -ge 1 ]]; then
                record_domain "$POSSIBLE_DOMAIN" "reverse DNS of ${candidate_ip}"
                record_dc_ip "$candidate_ip" "reverse DNS FQDN"
            fi
        fi
    done
fi

# ---- 5m: DC port signature scan (if nmap available) ----
log "${BLUE}[*] 5m: Scanning candidates for DC service ports...${NC}"
if has_tool nmap; then
    for candidate_ip in $CANDIDATE_IPS; do
        DC_PORTS=$(nmap -n -p88,135,139,389,445,464,636,3268,3269 --open -Pn "$candidate_ip" 2>/dev/null || true)
        echo "--- nmap DC ports @${candidate_ip} ---" >> "$ENUM_DETAIL_LOG"
        echo "$DC_PORTS" >> "$ENUM_DETAIL_LOG"

        # If port 88 (Kerberos) AND 389 (LDAP) are open, it's likely a DC
        if echo "$DC_PORTS" | grep -q "88/tcp.*open" && echo "$DC_PORTS" | grep -q "389/tcp.*open"; then
            log "${GREEN}[+] DC port signature confirmed @${candidate_ip} (88+389 open)${NC}"
            record_dc_ip "$candidate_ip" "nmap DC port signature"
        fi
        # 3268 = Global Catalog = definitely a DC
        if echo "$DC_PORTS" | grep -q "3268/tcp.*open"; then
            log "${GREEN}[+] Global Catalog @${candidate_ip} (port 3268 open)${NC}"
            record_dc_ip "$candidate_ip" "nmap Global Catalog 3268"
        fi
    done
else
    log "${YELLOW}[!] nmap not found — skipping DC port scan${NC}"
fi

# ============================================================
# STEP 5 SUMMARY: Write results
# ============================================================
echo -e "\n${CYAN}━━━ Step 5 Results ━━━${NC}"

if [[ -n "$DOMAIN" ]]; then
    log "${GREEN}[+] Domain (FQDN):   ${DOMAIN}${NC}"
else
    log "${YELLOW}[!] AD domain not discovered — may need manual investigation${NC}"
fi

if [[ -n "$NETBIOS_DOMAIN" ]]; then
    log "${GREEN}[+] Domain (NetBIOS): ${NETBIOS_DOMAIN}${NC}"
fi

# Write DC IPs to targets file
if [[ -n "$DC_IPS" ]]; then
    echo -e "$DC_IPS" | sort -u | grep -v '^$' > "$TARGETS_DIR/domain-controllers.txt"
    DC_COUNT=$(wc -l < "$TARGETS_DIR/domain-controllers.txt" | tr -d ' ')
    log "${GREEN}[+] ${DC_COUNT} domain controller(s) → ${TARGETS_DIR}/domain-controllers.txt${NC}"
    while IFS= read -r dc; do
        log "    ${dc}"
    done < "$TARGETS_DIR/domain-controllers.txt"
else
    touch "$TARGETS_DIR/domain-controllers.txt"
    DC_COUNT=0
    log "${YELLOW}[!] No domain controllers identified yet${NC}"
fi

# Write DC hostnames if found
if [[ -n "$DC_HOSTNAMES" ]]; then
    echo -e "$DC_HOSTNAMES" | sort -u | grep -v '^$' >> "$ENUM_DETAIL_LOG"
    log "${GREEN}[+] DC hostnames recorded in detail log${NC}"
fi

log "${BLUE}[*] Full enumeration detail: ${ENUM_DETAIL_LOG}${NC}"

# ============================================================
# STEP 6: ARP Neighbors
# ============================================================
echo -e "\n${CYAN}━━━ Step 6: ARP Neighbors ━━━${NC}"
echo "" >> "$LOGFILE"
echo "=== Step 6: ARP Neighbors ===" >> "$LOGFILE"

ARP_COUNT=0

if command -v arp-scan &>/dev/null && [[ -n "$IFACE" ]]; then
    log "${BLUE}[*] Running arp-scan on ${IFACE}...${NC}"
    ARP_RESULT=$(sudo arp-scan -l -I "$IFACE" 2>/dev/null || echo "")
    if [[ -n "$ARP_RESULT" ]]; then
        echo "$ARP_RESULT" >> "$LOGFILE"
        ARP_COUNT=$(echo "$ARP_RESULT" | grep -cP '^\d+\.\d+\.\d+\.\d+' || echo "0")
        log "${GREEN}[+] arp-scan found ${ARP_COUNT} neighbors${NC}"
    else
        log "${YELLOW}[!] arp-scan requires root - falling back to ARP cache${NC}"
    fi
fi

if [[ "$ARP_COUNT" -eq 0 ]]; then
    log "${BLUE}[*] Reading ARP cache...${NC}"
    if [[ "$PLATFORM" == "linux" ]]; then
        ARP_TABLE=$(ip neigh show 2>/dev/null | grep -v FAILED || arp -an 2>/dev/null)
    else
        ARP_TABLE=$(arp -an 2>/dev/null)
    fi

    if [[ -n "$ARP_TABLE" ]]; then
        echo "$ARP_TABLE" >> "$LOGFILE"
        ARP_COUNT=$(echo "$ARP_TABLE" | wc -l | tr -d ' ')
        log "${GREEN}[+] ARP cache has ${ARP_COUNT} entries${NC}"
        echo "$ARP_TABLE" | head -10 | while IFS= read -r line; do
            log "    ${line}"
        done
        if [[ "$ARP_COUNT" -gt 10 ]]; then
            log "    ... (${ARP_COUNT} total, see log for full list)"
        fi
    else
        log "${YELLOW}[!] ARP cache is empty${NC}"
    fi
fi

# ============================================================
# STEP 7: Basic Connectivity Checks
# ============================================================
echo -e "\n${CYAN}━━━ Step 7: Connectivity Checks ━━━${NC}"
echo "" >> "$LOGFILE"
echo "=== Step 7: Connectivity Checks ===" >> "$LOGFILE"

# Ping gateway
if [[ -n "$GATEWAY" ]]; then
    if ping -c 1 -W 2 "$GATEWAY" &>/dev/null; then
        log "${GREEN}[+] Gateway ${GATEWAY} is reachable${NC}"
    else
        log "${RED}[!] Gateway ${GATEWAY} is NOT reachable${NC}"
    fi
fi

# Ping DCs
if [[ -f "$TARGETS_DIR/domain-controllers.txt" ]]; then
    while IFS= read -r dc_ip; do
        [[ -z "$dc_ip" ]] && continue
        if ping -c 1 -W 2 "$dc_ip" &>/dev/null; then
            log "${GREEN}[+] DC ${dc_ip} is reachable${NC}"
        else
            log "${YELLOW}[!] DC ${dc_ip} is NOT reachable (may block ICMP)${NC}"
        fi
    done < "$TARGETS_DIR/domain-controllers.txt"
fi

# Check DNS resolution
if [[ -n "$DOMAIN" ]]; then
    if nslookup "$DOMAIN" &>/dev/null || dig "$DOMAIN" +short &>/dev/null; then
        log "${GREEN}[+] DNS resolution for ${DOMAIN} works${NC}"
    else
        log "${YELLOW}[!] DNS resolution for ${DOMAIN} failed${NC}"
    fi
fi

# ============================================================
# SUMMARY
# ============================================================
echo -e "\n${GREEN}╔══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${GREEN}║  Initial Discovery Complete                                ║${NC}"
echo -e "${GREEN}╚══════════════════════════════════════════════════════════════╝${NC}"
echo ""

echo "" >> "$LOGFILE"
echo "=== Summary ===" >> "$LOGFILE"

echo -e "  ${BLUE}Platform:${NC}            ${GREEN}${PLATFORM}${NC}"
echo -e "  ${BLUE}Interface:${NC}           ${GREEN}${IFACE:-unknown}${NC}"
echo -e "  ${BLUE}Local IP:${NC}            ${GREEN}${LOCAL_IP:-unknown}${NC}"
echo -e "  ${BLUE}Subnet CIDR:${NC}         ${GREEN}${NETWORK_CIDR:-unknown}${NC}"
echo -e "  ${BLUE}Gateway:${NC}             ${GREEN}${GATEWAY:-unknown}${NC}"
echo -e "  ${BLUE}DNS Servers:${NC}         ${GREEN}${DNS_SERVERS:-unknown}${NC}"
echo -e "  ${BLUE}AD Domain (FQDN):${NC}   ${GREEN}${DOMAIN:-not found}${NC}"
echo -e "  ${BLUE}AD Domain (NetBIOS):${NC} ${GREEN}${NETBIOS_DOMAIN:-not found}${NC}"

if [[ -f "$TARGETS_DIR/domain-controllers.txt" ]]; then
    DC_FINAL_COUNT=$(wc -l < "$TARGETS_DIR/domain-controllers.txt" | tr -d ' ')
    echo -e "  ${BLUE}Domain Controllers:${NC}  ${GREEN}${DC_FINAL_COUNT}${NC}"
fi

echo -e "  ${BLUE}ARP Neighbors:${NC}       ${GREEN}${ARP_COUNT}${NC}"
echo ""
echo -e "  ${BLUE}Log:${NC}                 ${LOGFILE}"
echo -e "  ${BLUE}Enum Detail:${NC}         ${ENUM_DETAIL_LOG}"
echo -e "  ${BLUE}Ranges:${NC}              ${TARGETS_DIR}/ranges.txt"
echo -e "  ${BLUE}DCs:${NC}                 ${TARGETS_DIR}/domain-controllers.txt"
echo ""

# Summary to log
{
    echo "Platform:           ${PLATFORM}"
    echo "Interface:          ${IFACE:-unknown}"
    echo "Local IP:           ${LOCAL_IP:-unknown}"
    echo "Subnet CIDR:        ${NETWORK_CIDR:-unknown}"
    echo "Gateway:            ${GATEWAY:-unknown}"
    echo "DNS Servers:        ${DNS_SERVERS:-unknown}"
    echo "AD Domain (FQDN):   ${DOMAIN:-not found}"
    echo "AD Domain (NetBIOS):${NETBIOS_DOMAIN:-not found}"
    echo "ARP Neighbors:      ${ARP_COUNT}"
} >> "$LOGFILE"

# Next steps
echo -e "${GREEN}[+] Next Steps:${NC}"
if [[ -n "$NETWORK_CIDR" ]]; then
    echo -e "  1. Verify scope: ${CYAN}cat ${TARGETS_DIR}/ranges.txt${NC}"
    echo -e "  2. Run network discovery: ${CYAN}./network-discovery.sh ${NETWORK_CIDR}${NC}"
else
    echo -e "  1. Determine your subnet and create ${TARGETS_DIR}/ranges.txt"
    echo -e "  2. Run network discovery: ${CYAN}./network-discovery.sh <CIDR>${NC}"
fi
echo -e "  3. If domain found, note it in Scope.md"
echo -e "  4. Confirm scope ranges with client before active scanning"
echo ""
