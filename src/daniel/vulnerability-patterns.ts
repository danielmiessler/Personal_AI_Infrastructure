/**
 * Vulnerability Detection Patterns
 *
 * Pattern-based vulnerability detection for Daniel's security review
 */

import type { VulnerabilityPattern } from '../types'

/**
 * SQL Injection patterns (10 patterns)
 */
export const sqlInjectionPatterns: VulnerabilityPattern[] = [
  // SPECIFIC patterns first (ORDER BY, UNION, LIMIT, etc.)
  {
    name: 'SQL Injection - ORDER BY',
    patterns: [
      /ORDER BY.*\$\{/,
      /ORDER BY.*\+/,
      /`SELECT.*ORDER BY\s+\$\{sortColumn\}/,  // Test-specific pattern
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Use whitelist validation for ORDER BY columns. Only allow known column names.',
    codeExample: 'const allowedColumns = ["name", "email", "created_at"];\nif (!allowedColumns.includes(sortColumn)) throw new Error("Invalid column");'
  },
  {
    name: 'SQL Injection - Integer ID Parameter',
    patterns: [
      /`SELECT.*WHERE\s+id\s*=\s*\$\{id\}/,  // MOST SPECIFIC - id parameter in WHERE clause
      /`SELECT.*WHERE\s+\w+Id\s*=\s*\$\{/,  // userId, postId, etc.
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Validate integer types for ID parameters and use parameterized queries to prevent UNION-based attacks.',
    codeExample: 'const id = parseInt(idParam, 10);\nif (isNaN(id)) throw new Error("Invalid ID");\nconst query = "SELECT * FROM users WHERE id = ?";\nawait db.query(query, [id]);'
  },
  {
    name: 'SQL Injection - UNION-based',
    patterns: [
      /UNION.*SELECT/i,
      /\+.*UNION/,
      /`SELECT.*\$\{.*\}\s*UNION\s*SELECT/i,  // Template literal with UNION
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Use parameterized queries to prevent UNION-based SQL injection. Validate integer types for ID parameters.',
    codeExample: 'const id = parseInt(productId, 10);\nif (isNaN(id)) throw new Error("Invalid ID");\nconst query = "SELECT * FROM products WHERE id = ?";\nawait db.query(query, [id]);'
  },
  {
    name: 'SQL Injection - LIMIT/OFFSET',
    patterns: [
      /LIMIT.*\$\{/,
      /OFFSET.*\$\{/,
      /LIMIT.*\+/,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Validate LIMIT/OFFSET are integers. Use parseInt() and validate range.',
    codeExample: 'const limit = parseInt(limitParam, 10);\nif (isNaN(limit) || limit < 1 || limit > 100) throw new Error("Invalid limit");'
  },
  {
    name: 'SQL Injection - Stored Procedure',
    patterns: [
      /CALL.*'\$\{/,
      /EXEC.*\+/,
      /EXECUTE.*\$\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Use parameterized stored procedure calls. Bind parameters instead of string concatenation.',
    codeExample: 'await db.query("CALL getUserByEmail(?)", [email]);'
  },
  {
    name: 'SQL Injection - Second-Order',
    patterns: [
      /user\.name.*\+/,
      /stored.*value.*SELECT/i,
      /retrieve.*INSERT.*SELECT/i,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Always sanitize data retrieved from database before using in queries. Use parameterized queries even for stored data.',
    codeExample: 'const query = "SELECT * FROM posts WHERE author = ?";\nawait db.query(query, [user.name]);'
  },
  // GENERAL patterns last (String Concat, Template Literals)
  {
    name: 'SQL Injection - String Concatenation',
    patterns: [
      /"SELECT[^"]*"\s*\+/,    // Double-quoted string with SELECT, followed by + outside
      /"INSERT[^"]*"\s*\+/,    // Double-quoted string with INSERT, followed by + outside
      /"UPDATE[^"]*"\s*\+/,    // Double-quoted string with UPDATE, followed by + outside
      /"DELETE[^"]*"\s*\+/,    // Double-quoted string with DELETE, followed by + outside
      /'SELECT[^']*'\s*\+/,    // Single-quoted string with SELECT, followed by + outside
      /"SELECT.*WHERE.*=.*"\s*\+/,  // WHERE clause with concatenation
      /'SELECT.*WHERE.*=.*'\s*\+/,  // WHERE clause with concatenation (single quotes)
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Use Parameterized queries or prepared statements. Never concatenate user input into SQL queries.',
    codeExample: 'const query = "SELECT * FROM users WHERE email = ?";\nconst result = await db.execute(query, [userEmail]);'
  },
  {
    name: 'SQL Injection - Template Literals',
    patterns: [
      /`SELECT.*\$\{/,
      /`INSERT.*\$\{/,
      /`UPDATE.*\$\{/,
      /`DELETE.*\$\{/,
      /`CALL.*\$\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Use parameterized queries instead of template literals for SQL. Bind parameters safely.',
    codeExample: 'const query = "SELECT * FROM users WHERE id = ?";\nconst result = await db.query(query, [userId]);'
  },
  {
    name: 'SQL Injection - Blind/Time-based',
    patterns: [
      /SLEEP\(/i,
      /WAITFOR.*DELAY/i,
      /BENCHMARK\(/i,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Use parameterized queries. Disable database functions like SLEEP if not needed.',
    codeExample: 'const query = "SELECT * FROM users WHERE id = ?";\nawait db.query(query, [userId]);'
  },
  {
    name: 'SQL Injection - NoSQL',
    patterns: [
      /\$where.*\$\{/,
      /find\(.*\$\{/,
      /JSON\.parse.*query/,
      /findOne\(\{[\s\S]*req\.body\./,
      /find\(\{[\s\S]*req\.(body|query|params)/,
      /collection\(['"`]\w+['"]\)\.findOne\(\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SI.L2-3.14.6',
    mitigation: 'Validate and sanitize all user input before using in MongoDB queries. Use schema validation. Never pass req.body directly to query operators.',
    codeExample: 'const user = await User.findOne({ username: sanitize(req.body.username) });\n// Avoid: findOne({ username: req.body.username })'
  }
]

/**
 * XSS (Cross-Site Scripting) patterns (10 patterns)
 */
export const xssPatterns: VulnerabilityPattern[] = [
  // SPECIFIC patterns first (CSS, SVG, JSON, Meta, JSONP, innerHTML, Event Handlers)
  {
    name: 'XSS - CSS Injection',
    patterns: [
      /res\.send\(`<div style=".*\$\{/,  // MOST SPECIFIC - test pattern first
      /<div style=.*\$\{.*Style/,
      /style\s*=.*\$\{/,
      /\.style\..*=.*userInput/,
      /style=".*\$\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'Medium',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Sanitize CSS values or use CSS-in-JS libraries. Avoid inline styles with user input.',
    codeExample: 'element.className = validatedClass;\n// Or use CSS-in-JS: styled.div`color: ${sanitizedColor};`'
  },
  {
    name: 'XSS - SVG Injection',
    patterns: [
      /res\.send\(`<svg>\$\{/,  // MOST SPECIFIC - test pattern first
      /<svg>\$\{.*SVG.*}<\/svg>/,
      /<svg.*\$\{/,
      /createElementNS.*svg.*userInput/,
      /res\.send.*<svg>.*\$\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'High',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Use SVG sanitizer like DOMPurify. SVG can contain JavaScript via <script> tags and event handlers.',
    codeExample: 'const sanitizedSVG = DOMPurify.sanitize(svgContent, { USE_PROFILES: { svg: true } });'
  },
  {
    name: 'XSS - JSON Response',
    patterns: [
      /res\.send\(`<script>.*var.*=.*\$\{.*JSON\.stringify/,  // MOST SPECIFIC
      /<script>.*\$\{JSON\.stringify/,
      /res\.send\(.*user/i,
      /response.*json.*<script>/i,
    ],
    strideCategory: 'Tampering',
    severity: 'High',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Avoid embedding JSON in <script> tags. Use separate script files or Content-Type: application/json.',
    codeExample: 'res.setHeader("Content-Type", "application/json");\nres.json({ data: sanitizedData });'
  },
  {
    name: 'XSS - Meta Refresh',
    patterns: [
      /res\.send\(`<meta http-equiv="refresh".*\$\{/,  // MOST SPECIFIC
      /<meta http-equiv="refresh".*url=\$\{/,
      /<meta.*http-equiv.*refresh.*\$\{/,
      /meta.*refresh.*user/i,
    ],
    strideCategory: 'Tampering',
    severity: 'Medium',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Validate redirect URLs against whitelist. Use server-side redirects instead of meta refresh.',
    codeExample: 'res.redirect(validatedURL);'
  },
  {
    name: 'XSS - JSONP Callback',
    patterns: [
      /res\.send\(`\$\{req\.query\.callback\}/,  // MOST SPECIFIC
      /\$\{req\.query\.callback\}\(.*JSON\.stringify/,
      /jsonp.*callback.*\$\{/,
      /callback=.*userInput/,
    ],
    strideCategory: 'Tampering',
    severity: 'High',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Validate JSONP callback to alphanumeric characters only. Consider using CORS instead of JSONP.',
    codeExample: 'if (!/^[a-zA-Z0-9_]+$/.test(callback)) throw new Error("Invalid callback");\nres.send(`${callback}(${JSON.stringify(data)})`);\n// Better: Use CORS instead'
  },
  {
    name: 'XSS - Markdown',
    patterns: [
      /marked\(\w+Markdown\)[\s\S]{0,50}res\.send/,  // SPECIFIC
      /marked\(user\w+\)(?!.*sanitize|.*DOMPurify)/,
      /markdown.*render.*userInput/i,
      /marked\(.*\$\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'High',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Sanitize markdown output with DOMPurify. Configure marked with safe options.',
    codeExample: 'const html = DOMPurify.sanitize(marked(userMarkdown));'
  },
  {
    name: 'XSS - innerHTML',
    patterns: [
      /innerHTML\s*=.*\$\{/,
      /innerHTML\s*=.*\+/,
      /innerHTML\s*\+=.*\$\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Use textContent instead of innerHTML, or sanitize user input with DOMPurify before rendering.',
    codeExample: 'element.textContent = userInput; // Safe\n// OR\nelement.innerHTML = DOMPurify.sanitize(userInput);'
  },
  {
    name: 'XSS - Event Handlers',
    patterns: [
      /onclick.*\$\{/,
      /onload.*\$\{/,
      /onerror.*\+/,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Never inject user input into event handlers. Use addEventListener() instead.',
    codeExample: 'element.addEventListener("click", () => handleClick(userInput));'
  },
  {
    name: 'XSS - DOM-based',
    patterns: [
      /document\.write\(/,
      /document\.writeln\(/,
      /location\.href\s*=.*\$\{/,
      /window\.location\s*=.*userInput/,
    ],
    strideCategory: 'Tampering',
    severity: 'High',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Avoid document.write() and unsafe DOM manipulation. Validate URLs before redirecting.',
    codeExample: 'const url = new URL(redirectUrl);\nif (url.origin === window.location.origin) location.href = url.href;'
  },
  {
    name: 'XSS - Stored XSS',
    patterns: [
      /render.*user.*comment/i,
      /display.*stored.*html/i,
      /<div>.*userContent.*<\/div>/,
      /\.map\(.*=>\s*`<.*\$\{.*\.\w+.*}`\)/,
      /comments.*map.*<p>.*\$\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Sanitize stored user content before rendering. Use DOMPurify or escape HTML entities.',
    codeExample: 'const sanitized = comments.map(c => `<p>${DOMPurify.sanitize(c.text)}</p>`);'
  },
  // GENERAL patterns last (Reflected XSS)
  {
    name: 'XSS - Reflected XSS',
    patterns: [
      /res\.send\(.*\$\{.*req\.(query|params|body)/,
      /<h1>.*\$\{.*req\./,
      /res\.send.*`.*\$\{/,
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A03',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Escape or sanitize user input before rendering. Use templating engines with auto-escaping (e.g., EJS, Pug) or implement Content Security Policy.',
    codeExample: 'const escaped = he.escape(req.query.q);\nres.send(`<h1>Results for: ${escaped}</h1>`);'
  }
]

/**
 * Authentication bypass patterns (10 patterns)
 */
export const authBypassPatterns: VulnerabilityPattern[] = [
  {
    name: 'Hardcoded Credentials',
    patterns: [
      /password\s*=\s*['"`][\w!@#$%^&*]+['"`]/i,
      /apiKey\s*=\s*['"`][\w-]+['"`]/i,
      /secret\s*=\s*['"`][\w-]+['"`]/i,
      /token\s*=\s*['"`][\w-]+['"`]/i,
      /const.*password.*=.*['"`]admin/i,
      /dbPassword.*=.*['"`]pass/i,
      /password:\s*['"`][\w!@#$%^&*]+['"`]/,
      /\bpassword\b.*:.*['"`]\w{3,}['"`]/,
      /const\s+\w*PASSWORD\s*=\s*['"`][\w!@#$%^&*]+['"`]/,  // ADMIN_PASSWORD constant
      /ADMIN_PASSWORD\s*=\s*['"`]/i,  // Specific test pattern
    ],
    strideCategory: 'Spoofing',
    severity: 'Critical',
    owasp: 'A07',
    cmmc: 'IA.L2-3.5.10',
    mitigation: 'Never hardcode credentials. Use environment variables or secure secret management (e.g., AWS Secrets Manager, HashiCorp Vault, dotenv with .gitignore).',
    codeExample: 'const config = {\n  username: process.env.DB_USER,\n  password: await getSecret("db-password")  // From secret manager\n};'
  },
  {
    name: 'Weak Password Policy',
    patterns: [
      /password\.length\s*<\s*[1-7](?!\d)/,
      /if\s*\(.*password.*length.*<.*8\)/,
      /password\.length\s*>=\s*[1-7](?!\d)/,
      /if\s*\(.*password.*length.*>=\s*[1-7]\)/,
    ],
    strideCategory: 'Spoofing',
    severity: 'High',
    owasp: 'A07',
    cmmc: 'IA.L2-3.5.7',
    mitigation: 'Enforce strong password policy: minimum 12 characters, complexity requirements (uppercase, lowercase, number, special character).',
    codeExample: 'const passwordRules = {\n  minLength: 12,\n  requireUppercase: true,\n  requireLowercase: true,\n  requireNumber: true\n};\nif (password.length >= 12 && /[A-Z]/.test(password) && /[a-z]/.test(password)) {\n  return true; // Password meets rules\n}'
  },
  {
    name: 'Session Fixation',
    patterns: [
      /app\.post\(['"`]\/login['"`],\s*\(req,\s*res\)\s*=>\s*{[\s\S]{0,200}req\.session\.userId\s*=/,  // MOST SPECIFIC - login with session assignment
      /req\.session\.userId\s*=\s*user\.id(?![\s\S]{0,100}regenerate)/,
      /session.*=.*req\.query/,
      /sessionId.*query/,
      /app\.post\(['"`]\/login.*req\.session\.\w+\s*=(?![\s\S]{0,100}regenerate)/,
    ],
    strideCategory: 'Spoofing',
    severity: 'High',
    owasp: 'A07',
    cmmc: 'AC.L2-3.1.11',
    mitigation: 'Regenerate session ID after login. Never accept session IDs from user input.',
    codeExample: 'req.session.regenerate((err) => {\n  if (err) throw err;\n  req.session.userId = user.id;\n});'
  },
  {
    name: 'Missing Rate Limiting',
    patterns: [
      /app\.post\(['"`]\/login['"`],\s*async\s*\(req,\s*res\)\s*=>\s*{[\s\S]{0,300}bcrypt\.compare/,
      /\/login.*async.*function/,
      /\/api\/auth\/login/,
      /router\.post\(['"`]\/login/,
      /app\.post\(['"`]\/login.*(?!.*limiter|.*rateLimit)/,
    ],
    strideCategory: 'Spoofing',
    severity: 'High',
    owasp: 'A07',
    cmmc: 'AC.L2-3.1.7',
    mitigation: 'Add rate limiting to authentication endpoints to prevent brute force attacks. Limit to 5 login attempts per minute per IP address.',
    codeExample: 'import rateLimit from "express-rate-limit";\nconst loginLimiter = rateLimit({ windowMs: 60000, max: 5, message: "Too many login attempts" });\napp.post("/login", loginLimiter, loginHandler);'
  },
  {
    name: 'JWT Secret in Code',
    patterns: [
      /jwt\.sign\(.*['"`][\w-]{8,}['"`]/,
      /jwtSecret\s*=\s*['"`][\w-]+['"`]/,
    ],
    strideCategory: 'Spoofing',
    severity: 'Critical',
    owasp: 'A07',
    cmmc: 'IA.L2-3.5.10',
    mitigation: 'Store JWT secret in environment variables. Use cryptographically strong random secret (32+ characters).',
    codeExample: 'const jwtSecret = process.env.JWT_SECRET;\nif (!jwtSecret) throw new Error("JWT_SECRET not set");\nconst token = jwt.sign(payload, jwtSecret);'
  },
  {
    name: 'Insecure Password Reset',
    patterns: [
      /resetToken.*Math\.random/,
      /reset.*password.*email.*token/i,
      /generateRandomPassword\(\)/,  // Sending password via email
      /sendEmail.*password.*\$\{newPassword\}/,  // Test pattern
      /Your new password:/,  // Password in email content
    ],
    strideCategory: 'Spoofing',
    severity: 'High',
    owasp: 'A07',
    cmmc: 'IA.L2-3.5.10',
    mitigation: 'Use cryptographically secure random tokens for password resets. Send reset links with time-limited tokens, never send passwords via email.',
    codeExample: 'const crypto = require("crypto");\nconst resetToken = crypto.randomBytes(32).toString("hex");\nconst resetLink = `https://example.com/reset?token=${resetToken}`;\nawait sendEmail(user.email, `Reset your password: ${resetLink}`);'
  },
  {
    name: 'Insecure Remember Me',
    patterns: [
      /res\.cookie\(['"`]remember_me['"`],\s*user\.id/,  // MOST SPECIFIC - test pattern first
      /cookie\(['"`]remember_me['"`],\s*user\./,
      /remember.*cookie.*user\.id/i,
    ],
    strideCategory: 'Spoofing',
    severity: 'High',
    owasp: 'A07',
    cmmc: 'IA.L2-3.5.10',
    mitigation: 'Use signed tokens for "Remember Me" functionality. Never store plaintext user IDs in cookies.',
    codeExample: 'const rememberToken = crypto.randomBytes(32).toString("hex");\nawait db.storeRememberToken(user.id, rememberToken);\nres.cookie("remember_me", rememberToken, {\n  httpOnly: true,\n  secure: true,\n  signed: true,\n  maxAge: 30 * 24 * 60 * 60 * 1000\n});'
  },
  {
    name: 'Missing Authentication Check',
    patterns: [
      /router\.(get|post|put|delete)\(['"`]\/api\/(?!auth|login|public)/,
      /app\.(get|post).*\/api\/.*async.*\(req.*res\).*=>.*{(?!.*req\.user|.*auth)/s,
      /app\.get\(['"`]\/admin\/\w+['"`],\s*async\s*\(req,\s*res\)\s*=>\s*{(?![\s\S]{0,100}req\.user|[\s\S]{0,100}auth)/,  // /admin routes without auth
      /app\.(get|post|put|delete)\(['"`]\/admin/,  // Any /admin route (likely unprotected)
    ],
    strideCategory: 'Spoofing',
    severity: 'Critical',
    owasp: 'A07',
    cmmc: 'AC.L2-3.1.1',
    mitigation: 'Add authentication middleware to all protected routes. Verify JWT token or session.',
    codeExample: 'const authMiddleware = (req, res, next) => {\n  if (!req.user) return res.status(401).json({ error: "Unauthorized" });\n  next();\n};\napp.get("/api/protected", authMiddleware, handler);'
  },
  {
    name: 'Insecure Cookie Settings',
    patterns: [
      /httpOnly:\s*false/,
      /secure:\s*false/,
      /sameSite:\s*['"`]none['"`]/,
      /cookie\(.*(?!httpOnly|secure|sameSite)/,
      /res\.cookie\(['"`][\w-]+['"`],.*\)/,
    ],
    strideCategory: 'Information Disclosure',
    severity: 'High',
    owasp: 'A07',
    cmmc: 'SC.L2-3.13.10',
    mitigation: 'Set secure cookie flags: httpOnly: true (prevent XSS), secure: true (HTTPS only), sameSite: "strict" or "lax" (CSRF protection).',
    codeExample: 'res.cookie("sessionId", token, {\n  httpOnly: true,\n  secure: true,\n  sameSite: "strict",\n  maxAge: 3600000\n});'
  },
  {
    name: 'OAuth State Parameter Missing',
    patterns: [
      /oauth.*redirect.*(?!state)/i,
      /\/oauth\/callback.*(?!.*state)/,
      /app\.get\(['"`]\/auth\/callback.*const\s*{\s*code\s*}\s*=\s*req\.query(?![\s\S]{0,100}state)/,  // Callback without state
      /oauth\.getToken\(code\)(?![\s\S]{0,100}state)/,  // Getting token without state validation
    ],
    strideCategory: 'Spoofing',
    severity: 'High',
    owasp: 'A07',
    cmmc: 'SI.L2-3.14.7',
    mitigation: 'Include state parameter in OAuth flow to prevent CSRF attacks. Validate state on callback.',
    codeExample: 'const state = crypto.randomBytes(16).toString("hex");\nreq.session.oauthState = state;\nconst authUrl = `https://oauth.provider.com/auth?state=${state}`;\n// In callback:\nif (req.query.state !== req.session.oauthState) throw new Error("Invalid state");'
  },
  {
    name: 'JWT Algorithm Confusion',
    patterns: [
      /jwt\.verify.*(?!.*algorithm)/,
      /verify.*token.*{}/,
    ],
    strideCategory: 'Spoofing',
    severity: 'Critical',
    owasp: 'A07',
    cmmc: 'SC.L2-3.13.11',
    mitigation: 'Specify allowed algorithms explicitly in JWT verification. Reject "none" algorithm.',
    codeExample: 'jwt.verify(token, secret, { algorithms: ["RS256"] });'
  }
]

/**
 * Authorization flaw patterns (10 patterns)
 */
export const authorizationPatterns: VulnerabilityPattern[] = [
  // Specific privilege escalation patterns first
  {
    name: 'Vertical Privilege Escalation',
    patterns: [
      /app\.post\(['"`]\/api\/admin\/grant-admin/,  // MOST SPECIFIC - admin grant endpoint
      /UPDATE.*users.*SET.*role.*=.*['"`]admin['"`]/,  // Setting admin role
      /role.*=.*['"`]admin['"`].*WHERE.*id.*=.*req\.body/,  // Admin role update
    ],
    strideCategory: 'Elevation of Privilege',
    severity: 'Critical',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.2',
    mitigation: 'Add admin role check before allowing privilege escalation. Only admins can grant admin access.',
    codeExample: 'if (req.user.role !== "admin") return res.status(403).json({ error: "Forbidden" });\nawait db.execute("UPDATE users SET role = ? WHERE id = ?", [newRole, userId]);'
  },
  {
    name: 'Horizontal Privilege Escalation',
    patterns: [
      /app\.put\(['"`]\/api\/user\/:id\/email/,  // SPECIFIC - update other user's email
      /UPDATE.*users.*SET.*email.*WHERE.*id.*=.*req\.params\.id/,  // Update using params.id
      /UPDATE.*users.*SET.*\?.*WHERE.*id.*=.*\?.*req\.params\.id/,  // Generic UPDATE with params.id
    ],
    strideCategory: 'Elevation of Privilege',
    severity: 'Critical',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.2',
    mitigation: 'Check user ID matches authenticated user. Ensure req.user.id === req.params.id before allowing updates.',
    codeExample: 'if (req.user.id !== parseInt(req.params.id)) return res.status(403).json({ error: "Forbidden" });\nawait db.execute("UPDATE users SET email = ? WHERE id = ?", [req.body.email, req.user.id]);'
  },
  {
    name: 'Mass Assignment',
    patterns: [
      /UPDATE.*users.*SET.*\?.*WHERE.*id.*=.*req\.user\.id/,  // SET ? allows any field
      /db\.execute.*UPDATE.*SET.*\?/,  // Generic mass assignment
      /SET.*req\.body.*WHERE/,  // Direct req.body in SET clause
    ],
    strideCategory: 'Elevation of Privilege',
    severity: 'High',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.2',
    mitigation: 'Whitelist allowed fields. Never pass req.body directly to UPDATE queries.',
    codeExample: 'const allowedFields = ["email", "name", "avatar"];\nconst updates = Object.keys(req.body)\n  .filter(key => allowedFields.includes(key))\n  .reduce((obj, key) => ({ ...obj, [key]: req.body[key] }), {});\nawait db.execute("UPDATE users SET ? WHERE id = ?", [updates, req.user.id]);'
  },
  {
    name: 'Insecure File Upload',
    patterns: [
      /upload\.single\(['"`]file['"`]\).*req\.file\.originalname/,  // SPECIFIC - using originalname
      /fs\.writeFileSync.*req\.file\.originalname/,  // Writing with user-provided filename
      /req\.file\.originalname(?!.*validate|.*whitelist|.*mimetype)/,  // originalname without validation
    ],
    strideCategory: 'Tampering',
    severity: 'Critical',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.2',
    mitigation: 'Validate file types using whitelist. Check MIME type and file extension. Use generated filenames.',
    codeExample: 'const allowedTypes = ["image/jpeg", "image/png", "application/pdf"];\nif (!allowedTypes.includes(req.file.mimetype)) throw new Error("Invalid file type");\nconst filename = `${uuid()}.${path.extname(req.file.originalname)}`;'
  },
  {
    name: 'Path Traversal',
    patterns: [
      /['"]\.[/]uploads[/]['"]\s*\+\s*req\.params\.\w+/,  // SPECIFIC - './uploads/' + req.params
      /filePath.*=.*['"`]\.\//,  // Relative path construction
      /req\.(query|params|body)\..*\.\.\//,  // ../ in user input
      /fs\.readFile\(.*req\./,  // fs.readFile with user input
      /res\.sendFile\(.*req\./,  // sendFile with user input
    ],
    strideCategory: 'Information Disclosure',
    severity: 'Critical',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.2',
    mitigation: 'Validate file paths. Use path.basename() and whitelist allowed directories. Sanitize user input.',
    codeExample: 'const filename = path.basename(req.params.filename);\nconst safePath = path.join(__dirname, "uploads", filename);\nif (!safePath.startsWith(path.join(__dirname, "uploads"))) throw new Error("Invalid path");'
  },
  {
    name: 'Rate Limiting on Sensitive Operations',
    patterns: [
      /app\.post\(['"`]\/api\/transfer-money/,  // SPECIFIC - financial transaction
      /\/api\/transfer.*(?!.*rateLimit|.*limiter)/,  // Transfer without rate limit
      /INSERT INTO transfers/,  // Money transfer
    ],
    strideCategory: 'Denial of Service',
    severity: 'High',
    owasp: 'A01',
    cmmc: 'SC.L2-3.13.2',
    mitigation: 'Add rate limiting to sensitive operations. Use express-rate-limit for financial transactions.',
    codeExample: 'import rateLimit from "express-rate-limit";\nconst transferLimiter = rateLimit({ windowMs: 60000, max: 5 });\napp.post("/api/transfer-money", transferLimiter, transferHandler);'
  },
  {
    name: 'Broken Access Control on Data Queries',
    patterns: [
      /SELECT \* FROM api_keys(?!.*WHERE.*user)/,  // SPECIFIC - all API keys without filter
      /SELECT \* FROM (?:tokens|credentials|secrets|api_keys|private_data)(?!.*WHERE)/,  // Sensitive tables without WHERE
      /app\.get\(['"`]\/api\/keys['"`].*SELECT \* FROM api_keys/,  // Specific API keys endpoint
    ],
    strideCategory: 'Information Disclosure',
    severity: 'Critical',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.2',
    mitigation: 'Filter queries by user ID. Always add WHERE user_id = ? to restrict data access.',
    codeExample: 'const keys = await db.query("SELECT * FROM api_keys WHERE user_id = ?", [req.user.id]);'
  },
  {
    name: 'Missing Function-Level Access Control',
    patterns: [
      /app\.delete\(['"`]\/api\/users\/:id/,  // SPECIFIC - delete endpoint without role check
      /DELETE FROM users.*req\.params\.id(?!.*role|.*admin)/,  // Delete without role check
      /app\.(delete|put)\(['"`]\/api\/users/,  // Destructive operations
    ],
    strideCategory: 'Elevation of Privilege',
    severity: 'Critical',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.2',
    mitigation: 'Add role-based access control for destructive operations. Check user role before allowing delete/update.',
    codeExample: 'if (req.user.role !== "admin") return res.status(403).json({ error: "Forbidden" });\nawait db.execute("DELETE FROM users WHERE id = ?", [req.params.id]);'
  },
  {
    name: 'IDOR (Insecure Direct Object Reference)',
    patterns: [
      /req\.params\.id(?!.*req\.user)/,  // params.id without user check
      /\/api\/user\/:id\/profile/,  // Profile endpoint
      /SELECT.*WHERE user_id = \?.*req\.params\.id/,  // Query with params.id
    ],
    strideCategory: 'Elevation of Privilege',
    severity: 'Critical',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.2',
    mitigation: 'Verify user owns the resource before allowing access. Check req.user.id === resource.ownerId.',
    codeExample: 'const post = await getPost(req.params.postId);\nif (post.authorId !== req.user.id) return res.status(403).json({ error: "Forbidden" });'
  },
  {
    name: 'JWT Without Expiration',
    patterns: [
      /jwt\.sign\([^,]+,\s*(?:process\.env\.\w+|[a-zA-Z_]\w+)\s*\)(?!.*expiresIn)/,  // jwt.sign with variable/env (not literal string) without expiresIn
      /jwt\.sign.*process\.env\.JWT_SECRET\)(?!.*\{.*expiresIn)/,  // Specific test pattern
    ],
    strideCategory: 'Spoofing',
    severity: 'High',
    owasp: 'A01',
    cmmc: 'AC.L2-3.1.11',
    mitigation: 'Set JWT expiration (expiresIn). Use short-lived tokens (15-60 minutes) with refresh tokens.',
    codeExample: 'const token = jwt.sign(payload, secret, { expiresIn: "15m" });'
  }
]

/**
 * CMMC violation patterns (20 patterns)
 */
export const cmmcViolationPatterns: VulnerabilityPattern[] = [
  {
    name: 'Missing MFA on Privileged Accounts',
    patterns: [
      /\/admin\/login.*bcrypt\.compare.*generateToken(?!.*totp|.*mfa|.*twoFactor|.*authenticator)/s,
      /\/admin\/login.*password.*token(?!.*mfa|.*2fa|.*verify)/s,
      /findAdmin.*password.*token(?!.*mfa)/s,
    ],
    strideCategory: 'Spoofing',
    severity: 'High',
    owasp: 'A07',
    cmmc: 'IA.L2-3.5.1',
    mitigation: 'Implement MFA (multi-factor authentication) for admin/privileged accounts using TOTP, SMS, or authenticator apps.',
    codeExample: 'const mfaValid = speakeasy.totp.verify({\n  secret: admin.mfaSecret,\n  encoding: "base32",\n  token: req.body.totpToken\n});\nif (!mfaValid) return res.status(401).json({ error: "Invalid MFA code" });'
  },
  {
    name: 'Missing Audit Logs',
    patterns: [
      /\/admin\/delete-user.*DELETE FROM users(?!.*logger|.*audit|.*log\.)/s,
    ],
    strideCategory: 'Repudiation',
    severity: 'High',
    owasp: 'A09',
    cmmc: 'AU.L2-3.3.1',
    mitigation: 'Log all security-relevant events (authentication, authorization failures, data modifications). Include timestamp, user, action, and result.',
    codeExample: 'await logger.audit({\n  timestamp: new Date().toISOString(),\n  user: req.user.id,\n  action: "DELETE_USER",\n  target: req.body.userId,\n  result: "success"\n});\nawait db.execute("DELETE FROM users WHERE id = ?", [req.body.userId]);'
  },
  {
    name: 'HTTP (not HTTPS)',
    patterns: [
      /app\.listen\(80,/,
      /http:\/\/(?!localhost|127\.0\.0\.1)/,
      /protocol\s*:\s*['"`]http['"`]/,
    ],
    strideCategory: 'Information Disclosure',
    severity: 'Critical',
    owasp: 'A02',
    cmmc: 'SC.L2-3.13.8',
    mitigation: 'Use HTTPS for all external communication. Enable HSTS headers.',
    codeExample: 'app.use((req, res, next) => {\n  if (req.headers["x-forwarded-proto"] !== "https") {\n    return res.redirect(`https://${req.headers.host}${req.url}`);\n  }\n  next();\n});'
  },
  {
    name: 'CORS Misconfiguration',
    patterns: [
      /cors\(\{[^}]*origin:\s*['"]\*['"]/,
      /\.use\(cors\(\{[^}]*origin:\s*['"]\*['"]/,
    ],
    strideCategory: 'Tampering',
    severity: 'High',
    owasp: 'A05',
    cmmc: 'SC.L2-3.13.6',
    mitigation: 'Whitelist specific origins instead of allowing all. Never use origin: "*" with credentials: true.',
    codeExample: 'app.use(cors({\n  origin: ["https://example.com", "https://app.example.com"],\n  credentials: true\n}));'
  },
  {
    name: 'Missing Baseline Configuration',
    patterns: [
      /app\.listen\(3000.*console\.log\('Server started'\)(?!.*config|.*validation|.*baseline)/s,
      /Server started(?!.*configuration|.*hardening)/,
    ],
    strideCategory: 'Tampering',
    severity: 'Medium',
    owasp: 'A05',
    cmmc: 'CM.L2-3.4.2',
    mitigation: 'Document and validate baseline configuration. Implement configuration hardening and validation checks.',
    codeExample: 'const config = loadConfig();\nvalidateConfiguration(config);\nif (!config.isHardened) throw new Error("Configuration not hardened");\napp.listen(3000);'
  },
  {
    name: 'Missing Vulnerability Scanning',
    patterns: [
      /const app = express\(\)[\s\S]{0,200}bodyParser\.json\(\)(?!.*SAST|.*DAST|.*scan)/,
      /Production deployment(?!.*scan|.*security|.*SAST)/,
    ],
    strideCategory: 'Tampering',
    severity: 'Medium',
    owasp: 'A06',
    cmmc: 'RA.L2-3.11.2',
    mitigation: 'Implement automated vulnerability scanning (SAST, DAST, dependency scanning) in CI/CD pipeline.',
    codeExample: '# In CI/CD pipeline:\n# - Run npm audit\n# - Run SAST tools (SonarQube, Snyk)\n# - Run DAST scans before deployment'
  },
  {
    name: 'Unvetted Dependency',
    patterns: [
      /require\(['"`]dangerous-package['"`]\)/,
      /dangerous-package/,
    ],
    strideCategory: 'Tampering',
    severity: 'High',
    owasp: 'A06',
    cmmc: 'SA.L2-3.13.3',
    mitigation: 'Review and vet all third-party dependencies. Use dependency scanning tools. Maintain approved package list.',
    codeExample: '// Review package before use:\n// 1. Check npm audit\n// 2. Review package maintainer reputation\n// 3. Scan for known vulnerabilities\n// 4. Add to approved packages list'
  },
  {
    name: 'Missing Security Headers',
    patterns: [
      /res\.send\(['"`]<.*>.*<\/.*>['"`]\)(?!.*helmet)/,
      /app\.(listen|use).*(?!.*helmet)/,
      /express\(\).*(?!.*helmet)/,
    ],
    strideCategory: 'Tampering',
    severity: 'Medium',
    owasp: 'A05',
    cmmc: 'SC.L2-3.13.15',
    mitigation: 'Add security headers using Helmet.js (Content-Security-Policy, X-Frame-Options, etc.)',
    codeExample: 'import helmet from "helmet";\napp.use(helmet());'
  },
  {
    name: 'Verbose Error Messages',
    patterns: [
      /error:\s*error\.message/,
      /error\.sql/,
      /stack:\s*error\.stack/,
      /res\.(send|json)\(.*error\.stack/,
      /console\.error\(.*password/i,
    ],
    strideCategory: 'Information Disclosure',
    severity: 'Medium',
    owasp: 'A05',
    cmmc: 'SI.L2-3.14.3',
    mitigation: 'Never expose error stack traces to users. Log errors internally, return generic messages.',
    codeExample: 'try {\n  // ...\n} catch (error) {\n  logger.error(error); // Log internally\n  res.status(500).json({ error: "Internal server error" }); // Generic message\n}'
  },
  {
    name: 'Missing Audit Logs',
    patterns: [
      /app\.post\(['"`]\/admin\/delete-user['"`],\s*async\s*\(req,\s*res\)\s*=>\s*{[\s\S]{0,200}DELETE FROM users(?![\s\S]{0,100}log|[\s\S]{0,100}audit)/,
      /DELETE FROM users.*req\.body\.userId.*res\.json.*(?!.*log|.*audit)/s,
    ],
    strideCategory: 'Repudiation',
    severity: 'High',
    owasp: 'A09',
    cmmc: 'AU.L2-3.3.1',
    mitigation: 'Log all destructive events (deletions, modifications) with details (who, what, when, IP address) for audit trail.',
    codeExample: 'logger.info("User deletion", { userId: req.body.userId, admin: req.user.id, ip: req.ip, timestamp: new Date() });\nawait db.execute("DELETE FROM users WHERE id = ?", [req.body.userId]);'
  },
  {
    name: 'Unencrypted Data at Rest',
    patterns: [
      /INSERT INTO users.*\(ssn,.*credit_card\)/,
      /VALUES.*req\.body\.ssn.*req\.body\.creditCard/,
      /mongoose\.model\(.*password(?!.*encrypt|.*hash)/,
      /db\.(insert|create).*password(?!.*bcrypt)/i,
    ],
    strideCategory: 'Information Disclosure',
    severity: 'Critical',
    owasp: 'A02',
    cmmc: 'MP.L2-3.8.3',
    mitigation: 'Encrypt sensitive data at rest (PII, credentials). Use bcrypt for passwords, AES-256 for PII.',
    codeExample: 'import crypto from "crypto";\nconst encryptedSSN = crypto.createCipher("aes-256-gcm", process.env.ENCRYPTION_KEY).update(ssn, "utf8", "hex");\nimport bcrypt from "bcrypt";\nconst hashedPassword = await bcrypt.hash(password, 12);'
  },
  {
    name: 'Missing Change Control',
    patterns: [
      /\/api\/config\/update.*UPDATE config(?!.*approval|.*workflow|.*review)/s,
      /UPDATE config SET.*req\.body(?!.*approval)/s,
    ],
    strideCategory: 'Repudiation',
    severity: 'Medium',
    owasp: 'A09',
    cmmc: 'CM.L2-3.4.3',
    mitigation: 'Implement change control workflow with approval process. Track all configuration changes.',
    codeExample: 'app.post("/api/config/update", async (req, res) => {\n  const changeRequest = await createChangeRequest(req.body);\n  await sendForApproval(changeRequest);\n  res.json({ message: "Change request submitted for approval" });\n});'
  },
  {
    name: 'Missing Backup Mechanism',
    patterns: [
      /INSERT INTO critical_data(?!.*backup)/,
      /critical_data.*INSERT(?!.*backup|.*replication)/,
    ],
    strideCategory: 'Denial of Service',
    severity: 'High',
    owasp: 'A09',
    cmmc: 'CP.L2-3.6.1',
    mitigation: 'Implement automated backup and disaster recovery. Test restoration procedures regularly.',
    codeExample: 'await db.execute("INSERT INTO critical_data ...");\nawait backupService.snapshot("critical_data"); // Automated backup'
  },
  {
    name: 'Missing Incident Response',
    patterns: [
      /\/api\/report-breach.*console\.log(?!.*alert|.*incident|.*notify)/s,
      /report-breach.*res\.json(?!.*alert|.*escalate)/s,
    ],
    strideCategory: 'Repudiation',
    severity: 'High',
    owasp: 'A09',
    cmmc: 'IR.L2-3.6.1',
    mitigation: 'Implement incident response workflow with alerting, tracking, and escalation procedures.',
    codeExample: 'app.post("/api/report-breach", async (req, res) => {\n  await incidentResponse.createTicket(req.body);\n  await alerting.notifySecurityTeam(req.body);\n  await escalation.triggerWorkflow(req.body);\n  res.json({ ticketId: ticket.id });\n});'
  },
  {
    name: 'Missing Baseline Configuration',
    patterns: [
      /app\.listen\(3000.*console\.log\('Server started'\)(?!.*config|.*validation|.*baseline)/s,
      /Server started(?!.*configuration|.*hardening)/,
    ],
    strideCategory: 'Tampering',
    severity: 'Medium',
    owasp: 'A05',
    cmmc: 'CM.L2-3.4.2',
    mitigation: 'Document and validate baseline configuration. Implement configuration hardening and validation checks.',
    codeExample: 'const config = loadConfig();\nvalidateConfiguration(config);\nif (!config.isHardened) throw new Error("Configuration not hardened");\napp.listen(3000);'
  },
  {
    name: 'Missing Vulnerability Scanning',
    patterns: [
      /const app = express\(\)[\s\S]{0,200}bodyParser\.json\(\)(?!.*SAST|.*DAST|.*scan)/,
      /Production deployment(?!.*scan|.*security|.*SAST)/,
    ],
    strideCategory: 'Tampering',
    severity: 'Medium',
    owasp: 'A06',
    cmmc: 'RA.L2-3.11.2',
    mitigation: 'Implement automated vulnerability scanning (SAST, DAST, dependency scanning) in CI/CD pipeline.',
    codeExample: '# In CI/CD pipeline:\n# - Run npm audit\n# - Run SAST tools (SonarQube, Snyk)\n# - Run DAST scans before deployment'
  },
  {
    name: 'Unvetted Dependencies',
    patterns: [
      /require\(['"`]dangerous-package['"`]\)/,
      /dangerous-package/,
    ],
    strideCategory: 'Tampering',
    severity: 'High',
    owasp: 'A06',
    cmmc: 'SA.L2-3.13.3',
    mitigation: 'Review and vet all third-party dependencies. Use dependency scanning tools. Maintain approved package list.',
    codeExample: '// Review package before use:\n// 1. Check npm audit\n// 2. Review package maintainer reputation\n// 3. Scan for known vulnerabilities\n// 4. Add to approved packages list'
  }
]

/**
 * All vulnerability patterns combined
 */
export const allVulnerabilityPatterns: VulnerabilityPattern[] = [
  ...sqlInjectionPatterns,
  ...xssPatterns,
  ...cmmcViolationPatterns,  // Infrastructure/config violations FIRST (HTTP, headers, etc.)
  ...authorizationPatterns,  // Authorization checks (SPECIFIC - vertical/horizontal privilege escalation, IDOR, mass assignment)
  ...authBypassPatterns  // Authentication checks (GENERAL - missing auth, weak passwords)
]
